// generated by Textmapper; DO NOT EDIT

#include "json_parser.h"

#include <cstdint>
#include <string>
#include <unordered_set>

#include "json_lexer.h"
#include "absl/strings/str_format.h"


namespace json {
constexpr inline int16_t tmTranslate[] = {
       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     8,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     7,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     5,     2,     6,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     3,     2,     4,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
       2,     2,     2,     2,     2,     2,     1,     2,     9,    10,
      11,    12,    13,    14,    15,
};
constexpr size_t tmTranslateLen =
    sizeof(tmTranslate) / sizeof(tmTranslate[0]);

// In the Flex and Yacc token encoding, the first 256 values are reserved for
// single-byte tokens (usually punctuation). This function maps Flex produced
// numbers to the corresponding token ID in the Textmapper token space.
Token CreateTokenFromFlex(int32_t t) {
  if (t >= 0 && t < tmTranslateLen) {
    return Token(tmTranslate[t]);
  }
  return Token::INVALID_TOKEN;
}

[[maybe_unused]] constexpr int8_t fooState = 26;

std::unordered_set<int8_t> barStates = {
	0, 2, 19, 28,
};


constexpr inline absl::string_view tmNonterminals[] = {
  "JSONText",
  "JSONValue",
  "JSONValue_A",
  "EmptyObject",
  "lookahead_EmptyObject",
  "JSONObject",
  "lookahead_notEmptyObject",
  "JSONMember",
  "JSONMemberList",
  "JSONArray",
  "JSONElementList",
  "JSONElementListopt",
};
constexpr size_t tmNonterminalsLen =
    sizeof(tmNonterminals) / sizeof(tmNonterminals[0]);

std::string symbolName(int32_t sym) {
  if (sym == noToken) {
    return "<no-token>";
  }
  if (sym >= 0 && sym < static_cast<int32_t>(Token::NumTokens)) {
    return std::string(tokenStr[sym]);
  }
  if (sym >= static_cast<int32_t>(Token::NumTokens) &&
      sym - static_cast<int32_t>(Token::NumTokens) < tmNonterminalsLen) {
    return std::string(
        tmNonterminals[sym - static_cast<int32_t>(Token::NumTokens)]);
  }
  return absl::StrFormat("nonterminal(%d)", sym);
}

constexpr int32_t tmDefGoto[] = {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

constexpr int32_t tmGoto[] = {
	53, 26, 50, 16, 29, 39, 40, 33, 42, 43, 59, 62,
};

constexpr int32_t tmDefAct[] = {
	-1, 18, -1, 15, 16, 9, 10, 11, 0, 13, -1, 12, -1, 14, 27, -1, -1, -1, -1, -1,
	26, 17, 23, 20, -1, 24, -1, 28, -1, 19, -1, 7, 8, 1, 2, 3, 22, 5, 4, 6, 25,
	-1, -1, -1,
};

constexpr int32_t tmActionBase = -16;

constexpr int32_t tmAction[] = {
	10, -16, -3, -16, -16, -16, -16, -16, -16, -16, 11, -16, 19, -16, -16, -2,
	-5, 15, 45, 10, -16, -16, -16, -16, 20, -16, 1, -16, 23, -16, 46, -16, -16,
	-16, -16, -16, -16, -16, -16, -16, -16, 32, -16, -16,
};

constexpr int32_t tmTableLen = 72;

constexpr int8_t tmTable[] = {
	31, -22, -4, 30, 29, -31, -21, -5, -6, -32, -7, -8, -9, 31, -19, -4, 9, 42,
	9, -23, -5, -6, -20, -7, -8, -9, 31, -30, -4, 10, 10, 10, -45, -33, -34, 9,
	-35, -36, -37, 11, 12, 11, 12, 13, 37, 13, -24, -24, 10, -25, 8, 25, 14, 41,
	36, -26, -26, 10, 11, 12, 26, 15, 13, 40, 16, 0, 0, 38, 12, 27, 0, 39,
};

constexpr int8_t tmCheck[] = {
	3, 6, 5, 6, 6, 4, 8, 10, 11, 8, 13, 14, 15, 3, 3, 5, 0, 1, 2, 4, 10, 11, 3,
	13, 14, 15, 3, 7, 5, 0, 1, 2, 0, 10, 11, 19, 13, 14, 15, 0, 0, 2, 2, 0, 28,
	2, 1, 1, 19, 4, 0, 18, 2, 0, 28, 10, 10, 28, 19, 19, 18, 2, 19, 30, 2, -1,
	-1, 28, 28, 19, -1, 28,
};

constexpr int8_t tmRuleLen[] = {
	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 0, 4, 3, 0, 3, 1, 1, 3,
	3, 1, 3, 1, 0, 0,
};

constexpr int32_t tmRuleSymbol[] = {
	16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20,
	21, 21, 22, 23, 23, 24, 24, 25, 26, 26, 27, 27, 22,
};

constexpr uint32_t tmRuleType[] = {
  static_cast<uint32_t>(NodeType::JSONText), // JSONText : JSONValue_A
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : kw_null
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : 'true'
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : 'false'
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : JSONObject
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : EmptyObject
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : JSONArray
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : JSONString
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue : JSONNumber
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : kw_null
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : 'true'
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : 'false'
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : JSONObject
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : EmptyObject
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : JSONArray
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : JSONString
  static_cast<uint32_t>(NodeType::JSONValue), // JSONValue_A : JSONNumber
  static_cast<uint32_t>(NodeType::EmptyObject), // EmptyObject : lookahead_EmptyObject '{' '}'
  0, // lookahead_EmptyObject :
  static_cast<uint32_t>(NodeType::JSONObject) + (static_cast<uint32_t>(NodeFlags::Foo)<<16), // JSONObject : lookahead_notEmptyObject '{' JSONMemberList '}'
  static_cast<uint32_t>(NodeType::JSONObject) + (static_cast<uint32_t>(NodeFlags::Foo)<<16), // JSONObject : lookahead_notEmptyObject '{' '}'
  0, // lookahead_notEmptyObject :
  static_cast<uint32_t>(NodeType::JSONMember) + (static_cast<uint32_t>(NodeFlags::Foo)<<16), // JSONMember : JSONString ':' JSONValue
  static_cast<uint32_t>(NodeType::SyntaxProblem), // JSONMember : error
  0, // JSONMemberList : JSONMember
  0, // JSONMemberList : JSONMemberList .foo ',' JSONMember
  static_cast<uint32_t>(NodeType::JSONArray) + (static_cast<uint32_t>(NodeFlags::Foo)<<16), // JSONArray : .bar '[' JSONElementListopt ']'
  0, // JSONElementList : JSONValue_A
  0, // JSONElementList : JSONElementList ',' JSONValue_A
  0, // JSONElementListopt : JSONElementList
  0, // JSONElementListopt :
};

// set(first JSONValue_A) = LBRACE, LBRACK, JSONSTRING, JSONNUMBER, KW_NULL, TRUE, FALSE
[[maybe_unused]] constexpr int32_t Literals[] = {
	3, 5, 10, 11, 13, 14, 15,
};

// set(follow YYerror) = RBRACE, COMMA
[[maybe_unused]] constexpr int32_t afterErr[] = {
	4, 8,
};

int8_t gotoState(int8_t state, int32_t symbol) {
  if (symbol >= static_cast<int32_t>(Token::NumTokens)) {
    int32_t pos = tmGoto[symbol-static_cast<int32_t>(Token::NumTokens)] + state;
    if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == state) {
      return tmTable[pos];
    }
    return tmDefGoto[symbol-static_cast<int32_t>(Token::NumTokens)];
  }

  // Shifting a token.
  int32_t action = tmAction[state];
  if (action == tmActionBase) {
    return -1;
  }
  int32_t pos = action + symbol;
  if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == symbol) {
    action = tmTable[pos];
  } else {
    action = tmDefAct[state];
  }
  if (action < -1) {
    return -2-action;
  }
  return -1;
}

ABSL_MUST_USE_RESULT int32_t lookaheadNext(Lexer& lexer) {
  Token tok;
restart:
  tok = lexer.Next();
  switch (tok) {
  case Token::MULTILINECOMMENT:
  case Token::INVALID_TOKEN:
    goto restart;
  default:
    break;
  }
  return static_cast<int32_t>(tok);
}

ABSL_MUST_USE_RESULT bool lookahead(Lexer& lexer_to_copy, int32_t next,
                                    int8_t start, 
                                    int8_t end) {
  Lexer lexer = lexer_to_copy;

  std::vector<stackEntry> stack;
  stack.reserve(64);

  int8_t state = start;
  stack.push_back(stackEntry{.state = state});

  while (state != end) {
    int32_t action = tmAction[state];
    if (action > tmActionBase) {
      // Lookahead is needed.
      if (next == noToken) {
        next = lookaheadNext(lexer);
      }
      int32_t pos = action + next;
      if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == next) {
        action = tmTable[pos];
      } else {
        action = tmDefAct[state];
      }
    } else {
      action = tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      int32_t rule = action;
      auto ln = static_cast<int32_t>(tmRuleLen[rule]);

      stackEntry entry;
      entry.sym.symbol = tmRuleSymbol[rule];
      stack.resize(stack.size() - ln);
      if (debugSyntax) {
        LOG(INFO) << "lookahead reduced to: " << symbolName(entry.sym.symbol);
      }
      state = gotoState(stack.back().state, entry.sym.symbol);
      entry.state = state;
      stack.push_back(std::move(entry));
    } else if (action < -1) {
      // Shift.
      state = -2-action;
      stack.push_back(stackEntry{
          .sym = symbol{.symbol = next},
          .state = state,
      });
      if (debugSyntax) {
        LOG(INFO) << "lookahead shift: " << symbolName(next) << " ("
                  << lexer.Text() << ")";
      }
      if (state != -1 && next != eoiToken) {
        next = noToken;
      }
    }

    if (action == -1 || state == -1) {
      break;
    }
  }

  if (debugSyntax) {
    LOG(INFO) << "lookahead done: " << ((state == end) ? "true" : "false");
  }
  return state == end;
}

ABSL_MUST_USE_RESULT bool AtEmptyObject(Lexer& lexer, int32_t next) {
  if (debugSyntax) {
    LOG(INFO) << "lookahead EmptyObject; next: " << symbolName(next);
  }
  return lookahead(lexer, next, 1, 42);
}

void Parser::reportIgnoredToken(symbol sym) {
  NodeType t = NodeType::NoType;
  NodeFlags flags = NodeFlags::None;
  switch (Token(sym.symbol)) {
  case Token::MULTILINECOMMENT:
    t = NodeType::MultiLineComment;
    flags = static_cast<NodeFlags>(NodeFlags::Bar | NodeFlags::Foo);
    break;
  case Token::INVALID_TOKEN:
    t = NodeType::InvalidToken;
    break;
  default:
    return;
  }
  if (debugSyntax) {
    LOG(INFO) << "ignored: " << Token(sym.symbol) << " as " << t;
  }
  listener_(t, flags, sym.location);
}

bool Parser::willShift(int32_t symbol, std::vector<stackEntry>& stack, int size, int8_t state) {
  if (state == -1) {
    return false;
  }
  absl::InlinedVector<int8_t, 4> stack2 = {state};

  // parsing_stack = stack[:size] + stack2
  while (state != end_state_) {
    int32_t action = tmAction[state];
    if (action > tmActionBase) {
      int32_t pos = action + symbol;
      if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == symbol) {
        action = tmTable[pos];
      } else {
        action = tmDefAct[state];
      }
    } else {
      action = tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      int32_t rule = action;
      int32_t ln = tmRuleLen[rule];
      int32_t symbol = tmRuleSymbol[rule];

      if (ln > 0) {
        if (ln < stack2.size()) {
          state = stack2[stack2.size()-ln-1];
          stack2.resize(stack2.size() - ln);
        } else {
          size -= ln - stack2.size();
          state = stack[size-1].state;
          stack2.clear();
        }
      }
      state = gotoState(state, symbol);
      stack2.push_back(state);
    } else {
      return action < -1;
    }
  }
  return symbol == eoiToken;
}

int64_t Parser::skipBrokenCode(Lexer& lexer, std::vector<stackEntry>& stack, std::bitset<static_cast<size_t>(Token::NumTokens)>& recover_tokens) {
  int64_t ret = 0;
  while (next_symbol_.symbol != eoiToken && !recover_tokens[next_symbol_.symbol]) {
    if (debugSyntax) {
      LOG(INFO) << "skipped while recovering: " << symbolName(next_symbol_.symbol) << " ("
            << lexer.Text() << ")";
    }
  if (!pending_symbols_.empty()) {
    for (const auto& tok : pending_symbols_) {
      reportIgnoredToken(tok);
    }
    pending_symbols_.clear();
  }
  switch (Token(next_symbol_.symbol)) {
  case Token::JSONSTRING:
    listener_(NodeType::JsonString, NodeFlags::None, next_symbol_.location);
    break;
    default:
      break;
  }
    ret = next_symbol_.location.end;
    fetchNext(lexer, stack);
  }
  return ret;
}

bool Parser::recoverFromError(Lexer& lexer, std::vector<stackEntry>& stack) {
  std::bitset<static_cast<size_t>(Token::NumTokens)> recover_tokens;
  std::vector<int> recover_pos;

  if (debugSyntax) {
    LOG(INFO) << "broke at " << symbolName(next_symbol_.symbol) << " ("
            << lexer.Text() << ")";
  }

  for (size_t size = stack.size(); size > 0; size--) {
    if (gotoState(stack[size-1].state, errSymbol) == -1) {
      continue;
    }
    recover_pos.push_back(size);
  }
  if (recover_pos.empty()) {
    return false;
  }

  for (int32_t v : afterErr) {
    recover_tokens[v] = true;
  }
  if (next_symbol_.symbol == noToken) {
    fetchNext(lexer, stack);
  }
  // By default, insert 'error' in front of the next token.
  int64_t begin = next_symbol_.location.begin;
  int64_t end = begin;
  for (const auto& tok : pending_symbols_) {
    // Try to cover all nearby invalid tokens.
    if (Token(tok.symbol) == Token::INVALID_TOKEN) {
      if (begin > tok.location.begin) {
        begin = tok.location.begin;
      }
      end = tok.location.end;
    }
  }
  for (;;) {
    int64_t skip_end = skipBrokenCode(lexer, stack, recover_tokens);
    if (skip_end > end) {
      end = skip_end;
    }

    int matching_pos = 0;
    if (debugSyntax) {
      LOG(INFO) << "trying to recover on " << symbolName(next_symbol_.symbol);
    }
    for (int pos : recover_pos) {
      if (willShift(next_symbol_.symbol, stack, pos, gotoState(stack[pos-1].state, errSymbol))) {
        matching_pos = pos;
        break;
      }
    }
    if (matching_pos == 0) {
      if (next_symbol_.symbol == eoiToken) {
        return false;
      }
      recover_tokens[next_symbol_.symbol] = false;
      continue;
    }

    if (matching_pos < stack.size()) {
      if (begin == end) {
        // Avoid producing syntax problems covering trailing whitespace.
        end = stack.back().sym.location.end;
      }
      begin = stack[matching_pos].sym.location.begin;
    } else if (begin == end && !pending_symbols_.empty()) {
      // This means pending tokens don't contain InvalidTokens.
      for (const auto& tok : pending_symbols_) {
        reportIgnoredToken(tok);
      }
      pending_symbols_.clear();
    }
    if (begin != end) {
      // Consume trailing invalid tokens.
      for (const auto& tok : pending_symbols_) {
        if (Token(tok.symbol) == Token::INVALID_TOKEN && tok.location.end > end) {
          end = tok.location.end;
        }
      }
      int consumed = 0;
      for (; consumed < pending_symbols_.size(); consumed++) {
        auto& tok = pending_symbols_[consumed];
        if (tok.location.begin >= end) {
          break;
        }
        reportIgnoredToken(tok);
      }
      pending_symbols_.erase(pending_symbols_.begin(), pending_symbols_.begin() + consumed);
    }
    if (debugSyntax) {
      for (int i = stack.size()-1; i >= matching_pos; i--) {
        LOG(INFO) << "dropped from stack: " << symbolName(stack[i].sym.symbol);
      }
      LOG(INFO) << "recovered";
    }
    stack.resize(matching_pos);
    stack.push_back(stackEntry{
      .sym =  symbol{
        .symbol = errSymbol,
        .location = Lexer::Location(begin, end),
      },
      .state = gotoState(stack[matching_pos-1].state, errSymbol),
    });
    return true;
  }
}

void Parser::fetchNext(Lexer& lexer, std::vector<stackEntry>& stack) {
  Token tok;
  for (;;) {
    tok = lexer.Next();
    switch (tok) {
    case Token::MULTILINECOMMENT:
    case Token::INVALID_TOKEN:
      pending_symbols_.push_back(symbol{static_cast<int32_t>(tok),
                                      lexer.LastTokenLocation()});
      continue;
    default:
      break;
    }
    break;
  }

  next_symbol_.symbol = static_cast<int32_t>(tok);
  next_symbol_.location = lexer.LastTokenLocation();
}


absl::Status Parser::action0([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.value.b = rhs[0].value.a; }  return absl::OkStatus();
}
absl::Status Parser::action3([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.value.a = 5; }  return absl::OkStatus();
}
absl::Status Parser::action11([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.value.a = 5; }  return absl::OkStatus();
}
absl::Status Parser::action17([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.sym.location.begin = rhs[1].sym.location.begin; }  return absl::OkStatus();
}
absl::Status Parser::action19([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.sym.location.begin = rhs[1].sym.location.begin; }  return absl::OkStatus();
}
absl::Status Parser::action20([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.sym.location.begin = rhs[1].sym.location.begin; }  return absl::OkStatus();
}
absl::Status Parser::action22([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.value.c = a; }  return absl::OkStatus();
}
absl::Status Parser::action24([[maybe_unused]] stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs) {
{ lhs.value.d = b; }  return absl::OkStatus();
}

absl::Status Parser::applyRule(int32_t rule, stackEntry& lhs,
                        [[maybe_unused]] const stackEntry* rhs,
                        Lexer& lexer) {
  switch (rule) {
  case 0: // JSONText : JSONValue_A
{
  absl::Status action_result = action0(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 3: // JSONValue : 'false'
{
  absl::Status action_result = action3(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 11: // JSONValue_A : 'false'
{
  absl::Status action_result = action11(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 17: // EmptyObject : lookahead_EmptyObject '{' '}'
{
  absl::Status action_result = action17(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 19: // JSONObject : lookahead_notEmptyObject '{' JSONMemberList '}'
{
  absl::Status action_result = action19(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 20: // JSONObject : lookahead_notEmptyObject '{' '}'
{
  absl::Status action_result = action20(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 22: // JSONMember : JSONString ':' JSONValue
{
  absl::Status action_result = action22(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;
  case 24: // JSONMemberList : JSONMember
{
  absl::Status action_result = action24(lhs, rhs);
  if (!action_result.ok()) {
    return action_result;
  }
}
    break;

  case 31:
        if (AtEmptyObject(lexer, next_symbol_.symbol)) {
      lhs.sym.symbol = 20; /* lookahead_EmptyObject */
    } else {
      lhs.sym.symbol = 22; /* lookahead_notEmptyObject */
    }
    return absl::OkStatus();
  default:
    break;
  }

  uint32_t nt = tmRuleType[rule];
  if (nt != 0) {
    listener_(static_cast<NodeType>(nt&0xffff), static_cast<NodeFlags>(nt>>16), lhs.sym.location);
  }
  return absl::OkStatus();
}

// There are n symbols in the RHS. The locations can be accessed by
// get_location(i) where i is in [0, n-1].
ABSL_MUST_USE_RESULT Lexer::Location DefaultCreateLocationFromRHS(
    int32_t n, absl::FunctionRef<Lexer::Location(int32_t)> get_location) {
  return Lexer::Location(get_location(0).begin,
                         get_location(n-1).end);
}

absl::Status Parser::Parse(int8_t start, int8_t end, 
  Lexer& lexer) {
  pending_symbols_.clear();
  int8_t state = start;
  absl::Status lastErr = absl::OkStatus();
  Lexer::Location lastLoc;
  int recovering = 0;

  std::vector<stackEntry> stack;
  stack.reserve(startStackSize);
  stack.push_back(stackEntry{.state = state});
  end_state_ = end;
  fetchNext(lexer, stack);

  while (state != end) {
    int32_t action = tmAction[state];
    if (action > tmActionBase) {
      // Lookahead is needed.
      if (next_symbol_.symbol == noToken) {
        fetchNext(lexer, stack);
      }
      int32_t pos = action + next_symbol_.symbol;
      if (pos >= 0 && pos < tmTableLen && tmCheck[pos] == next_symbol_.symbol) {
        action = tmTable[pos];
      } else {
        action = tmDefAct[state];
      }
    } else {
      action = tmDefAct[state];
    }

    if (action >= 0) {
      // Reduce.
      int32_t rule = action;
      int32_t ln = tmRuleLen[rule];
      stackEntry entry;
      entry.sym.symbol = tmRuleSymbol[rule];
      const stackEntry* rhs = &stack[0] + stack.size() - ln;

      if (ln == 0) {
        entry.sym.location = Lexer::Location(stack.back().sym.location.end,
                                             stack.back().sym.location.end);
        entry.value = stack.back().value;
      } else {
        entry.sym.location = DefaultCreateLocationFromRHS(ln,
          [&](int32_t i) { return rhs[i].sym.location; });
        entry.value = rhs[0].value;
      }
      absl::Status ret = applyRule(rule, entry, rhs, lexer);
      if (!ret.ok()) {
        return ret;
      }
      // Avoid resizing twice, by keeping an extra token at the end.
      stack.resize(stack.size() - ln + 1);
      if (debugSyntax) {
        LOG(INFO) << "reduced to: " << symbolName(entry.sym.symbol)
                  << " consuming " << ln << " symbols, range "
                  << entry.sym.location;
      }
      state = gotoState(stack[stack.size()-2].state, entry.sym.symbol);
      entry.state = state;
      stack.back() = std::move(entry);

    } else if (action < -1) {
      // Shift.
      state = -2-action;
        if (debugSyntax) {
          LOG(INFO) << "shift: " << symbolName(next_symbol_.symbol) << " ("
                    << lexer.Text() << ")";
        }
        stack.emplace_back(stackEntry{
            .sym = std::move(next_symbol_),
            .state = state,
        });
  if (!pending_symbols_.empty()) {
    for (const auto& tok : pending_symbols_) {
      reportIgnoredToken(tok);
    }
    pending_symbols_.clear();
  }
        if (next_symbol_.symbol != eoiToken) {
  switch (Token(next_symbol_.symbol)) {
  case Token::JSONSTRING:
    listener_(NodeType::JsonString, NodeFlags::None, next_symbol_.location);
    break;
    default:
      break;
  }
          next_symbol_.symbol = noToken;
        }
        if (recovering > 0) {
          recovering--;
        }
    }
    if (action == -1 || state == -1) {
      if (recovering == 0) {
        if (next_symbol_.symbol == noToken) {
          fetchNext(lexer, stack);
        }
        lastErr = absl::InvalidArgumentError(absl::StrFormat(
            "Syntax error: line %d: %s", lexer.LastTokenLine(), lexer.Text()));
        if (!error_handler_(lastErr)) {
  if (!pending_symbols_.empty()) {
    for (const auto& tok : pending_symbols_) {
      reportIgnoredToken(tok);
    }
    pending_symbols_.clear();
  }
          return lastErr;
        }
      }

      recovering = 4;
      if (!recoverFromError(lexer, stack)) {
  if (!pending_symbols_.empty()) {
    for (const auto& tok : pending_symbols_) {
      reportIgnoredToken(tok);
    }
    pending_symbols_.clear();
  }
        return lastErr;
      }
      state = stack[stack.size()-1].state;
    }
  }

  return absl::OkStatus();
}
}  // namespace json















