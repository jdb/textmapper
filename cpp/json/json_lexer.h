// generated by Textmapper; DO NOT EDIT

#ifndef EXAMPLES_JSON_LEXER_H_
#define EXAMPLES_JSON_LEXER_H_

#include <cstdint>
#include <ostream>
#include <tuple>

#include "absl/strings/string_view.h"
#include "json_token.h"

namespace json {
inline constexpr absl::string_view bomSeq = "\xef\xbb\xbf";

class Lexer {
 public:
  // Lexer states.
  enum class State : std::uint32_t {
    Initial = 0,
    Foo = 1,
  };

  struct Location {
    Location(int64_t b = 0, int64_t e = 0) : begin(b), end(e) {}
    friend inline std::ostream& operator<<(std::ostream& os,
                                           const Location& l) {
      return os << "[" << l.begin << "-" << l.end << "]";
    }
    // Byte offsets into input buffer.
    int64_t begin;
    int64_t end;
  };

  explicit Lexer(absl::string_view input_source ABSL_ATTRIBUTE_LIFETIME_BOUND);

  // Next finds and returns the next token in source. The stream end is
  // indicated by Token.EOI.
  //
  // The token text can be retrieved later by calling the Text() method.
  ABSL_MUST_USE_RESULT Token Next();

  // Location of the last token returned by Next().
  ABSL_MUST_USE_RESULT Location LastTokenLocation() const {
    return Location(token_offset_, offset_);
  }
  // LastTokenLine returns the line number of the last token returned by Next()
  // (1-based).
  ABSL_MUST_USE_RESULT int64_t LastTokenLine() const { return token_line_; }
  // LastTokenColumn returns the column of the last token returned by Next()
  // (in bytes, 1-based).
  ABSL_MUST_USE_RESULT int64_t LastTokenColumn() const { return token_column_; }

  // Text returns the substring of the input corresponding to the last token.
  ABSL_MUST_USE_RESULT absl::string_view Text() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return source_.substr(token_offset_, offset_ - token_offset_);
  }

  void set_state(State state) { start_state_ = state; }
  ABSL_MUST_USE_RESULT State state() { return start_state_; }

 private:
  // Rewind can be used in lexer actions to accept a portion of a scanned token,
  // or to include more text into it.
  void Rewind(int64_t rewind_offset);

  absl::string_view source_;

  int32_t input_rune_ = 0;    // current character, -1 means end of input
  int64_t offset_ = 0;        // character offset
  int64_t token_offset_ = 0;  // last token byte offset
  int64_t line_ = 1;          // current line number (1-based)
  int64_t token_line_ = 1;    // last token line
  int64_t line_offset_ = 0;   // current line offset
  int64_t token_column_ = 1;  // last token column (in bytes)
  int64_t scan_offset_ = 0;   // scanning byte offset

  State start_state_ = State::Initial;  // lexer state, modifiable
};

inline std::ostream& operator<<(std::ostream& os, const Lexer& lexer) {
  return os << "json::Lexer at line " << lexer.LastTokenLine() << " location "
            << lexer.LastTokenLocation() << " last token was \"" << lexer.Text()
            << "\"";
}

}  // namespace json

#endif  // EXAMPLES_JSON_LEXER_H_
