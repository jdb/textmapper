// generated by Textmapper; DO NOT EDIT

package ast

import (
	"github.com/inspirer/textmapper/parsers/js"
	"github.com/inspirer/textmapper/parsers/js/selector"
)

// Interfaces.

type JsNode interface {
	JsNode() *Node
}

type Token struct {
	*Node
}

type NilNode struct{}

var nilInstance = &NilNode{}

// All types implement JsNode.
func (n Accessor) JsNode() *Node                  { return n.Node }
func (n AdditiveExpr) JsNode() *Node              { return n.Node }
func (n Arguments) JsNode() *Node                 { return n.Node }
func (n ArrayLiteral) JsNode() *Node              { return n.Node }
func (n ArrayPattern) JsNode() *Node              { return n.Node }
func (n ArrowFunc) JsNode() *Node                 { return n.Node }
func (n AssertClause) JsNode() *Node              { return n.Node }
func (n AssertEntry) JsNode() *Node               { return n.Node }
func (n AssertionKey) JsNode() *Node              { return n.Node }
func (n AssignmentExpr) JsNode() *Node            { return n.Node }
func (n AssignmentOperator) JsNode() *Node        { return n.Node }
func (n AsyncArrowFunc) JsNode() *Node            { return n.Node }
func (n AsyncFunc) JsNode() *Node                 { return n.Node }
func (n AsyncFuncExpr) JsNode() *Node             { return n.Node }
func (n AsyncGeneratorDeclaration) JsNode() *Node { return n.Node }
func (n AsyncGeneratorExpression) JsNode() *Node  { return n.Node }
func (n AsyncGeneratorMethod) JsNode() *Node      { return n.Node }
func (n AsyncMethod) JsNode() *Node               { return n.Node }
func (n Await) JsNode() *Node                     { return n.Node }
func (n AwaitExpr) JsNode() *Node                 { return n.Node }
func (n BindingRestElement) JsNode() *Node        { return n.Node }
func (n BitwiseAND) JsNode() *Node                { return n.Node }
func (n BitwiseOR) JsNode() *Node                 { return n.Node }
func (n BitwiseXOR) JsNode() *Node                { return n.Node }
func (n Block) JsNode() *Node                     { return n.Node }
func (n Body) JsNode() *Node                      { return n.Node }
func (n BreakStmt) JsNode() *Node                 { return n.Node }
func (n CallExpr) JsNode() *Node                  { return n.Node }
func (n Case) JsNode() *Node                      { return n.Node }
func (n Catch) JsNode() *Node                     { return n.Node }
func (n Class) JsNode() *Node                     { return n.Node }
func (n ClassBody) JsNode() *Node                 { return n.Node }
func (n ClassExpr) JsNode() *Node                 { return n.Node }
func (n CoalesceExpr) JsNode() *Node              { return n.Node }
func (n CommaExpr) JsNode() *Node                 { return n.Node }
func (n ComputedPropertyName) JsNode() *Node      { return n.Node }
func (n ConciseBody) JsNode() *Node               { return n.Node }
func (n Cond) JsNode() *Node                      { return n.Node }
func (n ConditionalExpr) JsNode() *Node           { return n.Node }
func (n ContinueStmt) JsNode() *Node              { return n.Node }
func (n DebuggerStmt) JsNode() *Node              { return n.Node }
func (n Declare) JsNode() *Node                   { return n.Node }
func (n DecoratorCall) JsNode() *Node             { return n.Node }
func (n DecoratorExpr) JsNode() *Node             { return n.Node }
func (n Default) JsNode() *Node                   { return n.Node }
func (n DefaultParameter) JsNode() *Node          { return n.Node }
func (n DoWhileStmt) JsNode() *Node               { return n.Node }
func (n ElementBinding) JsNode() *Node            { return n.Node }
func (n EmptyDecl) JsNode() *Node                 { return n.Node }
func (n EmptyStmt) JsNode() *Node                 { return n.Node }
func (n EqualityExpr) JsNode() *Node              { return n.Node }
func (n ExponentiationExpr) JsNode() *Node        { return n.Node }
func (n ExportClause) JsNode() *Node              { return n.Node }
func (n ExportDecl) JsNode() *Node                { return n.Node }
func (n ExportDefault) JsNode() *Node             { return n.Node }
func (n ExportSpec) JsNode() *Node                { return n.Node }
func (n ExprStmt) JsNode() *Node                  { return n.Node }
func (n Extends) JsNode() *Node                   { return n.Node }
func (n Finally) JsNode() *Node                   { return n.Node }
func (n ForBinding) JsNode() *Node                { return n.Node }
func (n ForCondition) JsNode() *Node              { return n.Node }
func (n ForFinalExpr) JsNode() *Node              { return n.Node }
func (n ForInStmt) JsNode() *Node                 { return n.Node }
func (n ForInStmtWithVar) JsNode() *Node          { return n.Node }
func (n ForOfStmt) JsNode() *Node                 { return n.Node }
func (n ForOfStmtWithVar) JsNode() *Node          { return n.Node }
func (n ForStmt) JsNode() *Node                   { return n.Node }
func (n ForStmtWithVar) JsNode() *Node            { return n.Node }
func (n Func) JsNode() *Node                      { return n.Node }
func (n FuncExpr) JsNode() *Node                  { return n.Node }
func (n Generator) JsNode() *Node                 { return n.Node }
func (n GeneratorExpr) JsNode() *Node             { return n.Node }
func (n GeneratorMethod) JsNode() *Node           { return n.Node }
func (n Getter) JsNode() *Node                    { return n.Node }
func (n IdentExpr) JsNode() *Node                 { return n.Node }
func (n IfStmt) JsNode() *Node                    { return n.Node }
func (n ImportDecl) JsNode() *Node                { return n.Node }
func (n ImportSpec) JsNode() *Node                { return n.Node }
func (n InExpr) JsNode() *Node                    { return n.Node }
func (n IndexAccess) JsNode() *Node               { return n.Node }
func (n Initializer) JsNode() *Node               { return n.Node }
func (n InstanceOfExpr) JsNode() *Node            { return n.Node }
func (n JSXAttributeName) JsNode() *Node          { return n.Node }
func (n JSXClosingElement) JsNode() *Node         { return n.Node }
func (n JSXElement) JsNode() *Node                { return n.Node }
func (n JSXElementName) JsNode() *Node            { return n.Node }
func (n JSXExpr) JsNode() *Node                   { return n.Node }
func (n JSXFragment) JsNode() *Node               { return n.Node }
func (n JSXLiteral) JsNode() *Node                { return n.Node }
func (n JSXNormalAttribute) JsNode() *Node        { return n.Node }
func (n JSXOpeningElement) JsNode() *Node         { return n.Node }
func (n JSXSelfClosingElement) JsNode() *Node     { return n.Node }
func (n JSXSpreadAttribute) JsNode() *Node        { return n.Node }
func (n JSXSpreadExpr) JsNode() *Node             { return n.Node }
func (n JSXText) JsNode() *Node                   { return n.Node }
func (n LabelIdent) JsNode() *Node                { return n.Node }
func (n LabelledStmt) JsNode() *Node              { return n.Node }
func (n LetOrConst) JsNode() *Node                { return n.Node }
func (n LexicalBinding) JsNode() *Node            { return n.Node }
func (n LexicalDecl) JsNode() *Node               { return n.Node }
func (n Literal) JsNode() *Node                   { return n.Node }
func (n LiteralPropertyName) JsNode() *Node       { return n.Node }
func (n LogicalAND) JsNode() *Node                { return n.Node }
func (n LogicalOR) JsNode() *Node                 { return n.Node }
func (n MemberMethod) JsNode() *Node              { return n.Node }
func (n MemberVar) JsNode() *Node                 { return n.Node }
func (n Method) JsNode() *Node                    { return n.Node }
func (n Module) JsNode() *Node                    { return n.Node }
func (n ModuleSpec) JsNode() *Node                { return n.Node }
func (n MultiplicativeExpr) JsNode() *Node        { return n.Node }
func (n NameIdent) JsNode() *Node                 { return n.Node }
func (n NameSpaceImport) JsNode() *Node           { return n.Node }
func (n NamedImports) JsNode() *Node              { return n.Node }
func (n NamedTupleMember) JsNode() *Node          { return n.Node }
func (n NewExpr) JsNode() *Node                   { return n.Node }
func (n NewTarget) JsNode() *Node                 { return n.Node }
func (n NoElement) JsNode() *Node                 { return n.Node }
func (n NotExpr) JsNode() *Node                   { return n.Node }
func (n ObjectLiteral) JsNode() *Node             { return n.Node }
func (n ObjectMethod) JsNode() *Node              { return n.Node }
func (n ObjectPattern) JsNode() *Node             { return n.Node }
func (n OptionalCallExpr) JsNode() *Node          { return n.Node }
func (n OptionalIndexAccess) JsNode() *Node       { return n.Node }
func (n OptionalPropertyAccess) JsNode() *Node    { return n.Node }
func (n OptionalTaggedTemplate) JsNode() *Node    { return n.Node }
func (n Parameters) JsNode() *Node                { return n.Node }
func (n Parenthesized) JsNode() *Node             { return n.Node }
func (n PostDec) JsNode() *Node                   { return n.Node }
func (n PostInc) JsNode() *Node                   { return n.Node }
func (n PreDec) JsNode() *Node                    { return n.Node }
func (n PreInc) JsNode() *Node                    { return n.Node }
func (n Property) JsNode() *Node                  { return n.Node }
func (n PropertyAccess) JsNode() *Node            { return n.Node }
func (n PropertyBinding) JsNode() *Node           { return n.Node }
func (n ReferenceIdent) JsNode() *Node            { return n.Node }
func (n Regexp) JsNode() *Node                    { return n.Node }
func (n RelationalExpr) JsNode() *Node            { return n.Node }
func (n RestParameter) JsNode() *Node             { return n.Node }
func (n ReturnStmt) JsNode() *Node                { return n.Node }
func (n Setter) JsNode() *Node                    { return n.Node }
func (n ShiftExpr) JsNode() *Node                 { return n.Node }
func (n ShorthandProperty) JsNode() *Node         { return n.Node }
func (n SingleNameBinding) JsNode() *Node         { return n.Node }
func (n SpreadElement) JsNode() *Node             { return n.Node }
func (n SpreadProperty) JsNode() *Node            { return n.Node }
func (n Static) JsNode() *Node                    { return n.Node }
func (n StaticBlock) JsNode() *Node               { return n.Node }
func (n SuperExpr) JsNode() *Node                 { return n.Node }
func (n SwitchStmt) JsNode() *Node                { return n.Node }
func (n SyntaxProblem) JsNode() *Node             { return n.Node }
func (n TaggedTemplate) JsNode() *Node            { return n.Node }
func (n TemplateLiteral) JsNode() *Node           { return n.Node }
func (n This) JsNode() *Node                      { return n.Node }
func (n ThisExpr) JsNode() *Node                  { return n.Node }
func (n ThrowStmt) JsNode() *Node                 { return n.Node }
func (n TryStmt) JsNode() *Node                   { return n.Node }
func (n TsAbstract) JsNode() *Node                { return n.Node }
func (n TsAccessibilityModifier) JsNode() *Node   { return n.Node }
func (n TsAmbientBinding) JsNode() *Node          { return n.Node }
func (n TsAmbientClass) JsNode() *Node            { return n.Node }
func (n TsAmbientEnum) JsNode() *Node             { return n.Node }
func (n TsAmbientExportDecl) JsNode() *Node       { return n.Node }
func (n TsAmbientFunc) JsNode() *Node             { return n.Node }
func (n TsAmbientGlobal) JsNode() *Node           { return n.Node }
func (n TsAmbientImportAlias) JsNode() *Node      { return n.Node }
func (n TsAmbientInterface) JsNode() *Node        { return n.Node }
func (n TsAmbientModule) JsNode() *Node           { return n.Node }
func (n TsAmbientNamespace) JsNode() *Node        { return n.Node }
func (n TsAmbientTypeAlias) JsNode() *Node        { return n.Node }
func (n TsAmbientVar) JsNode() *Node              { return n.Node }
func (n TsArrayType) JsNode() *Node               { return n.Node }
func (n TsAsConstExpr) JsNode() *Node             { return n.Node }
func (n TsAsExpr) JsNode() *Node                  { return n.Node }
func (n TsAssertsType) JsNode() *Node             { return n.Node }
func (n TsCallSignature) JsNode() *Node           { return n.Node }
func (n TsCastExpr) JsNode() *Node                { return n.Node }
func (n TsConditional) JsNode() *Node             { return n.Node }
func (n TsConst) JsNode() *Node                   { return n.Node }
func (n TsConstructSignature) JsNode() *Node      { return n.Node }
func (n TsConstructorType) JsNode() *Node         { return n.Node }
func (n TsDynamicImport) JsNode() *Node           { return n.Node }
func (n TsEnum) JsNode() *Node                    { return n.Node }
func (n TsEnumBody) JsNode() *Node                { return n.Node }
func (n TsEnumMember) JsNode() *Node              { return n.Node }
func (n TsExclToken) JsNode() *Node               { return n.Node }
func (n TsExport) JsNode() *Node                  { return n.Node }
func (n TsExportAssignment) JsNode() *Node        { return n.Node }
func (n TsFuncType) JsNode() *Node                { return n.Node }
func (n TsImplementsClause) JsNode() *Node        { return n.Node }
func (n TsImportAliasDecl) JsNode() *Node         { return n.Node }
func (n TsImportRequireDecl) JsNode() *Node       { return n.Node }
func (n TsImportType) JsNode() *Node              { return n.Node }
func (n TsImportTypeStart) JsNode() *Node         { return n.Node }
func (n TsIndexMemberDecl) JsNode() *Node         { return n.Node }
func (n TsIndexSignature) JsNode() *Node          { return n.Node }
func (n TsIndexedAccessType) JsNode() *Node       { return n.Node }
func (n TsInterface) JsNode() *Node               { return n.Node }
func (n TsInterfaceExtends) JsNode() *Node        { return n.Node }
func (n TsIntersectionType) JsNode() *Node        { return n.Node }
func (n TsKeyOfType) JsNode() *Node               { return n.Node }
func (n TsLiteralType) JsNode() *Node             { return n.Node }
func (n TsMappedType) JsNode() *Node              { return n.Node }
func (n TsMethodSignature) JsNode() *Node         { return n.Node }
func (n TsNamespace) JsNode() *Node               { return n.Node }
func (n TsNamespaceBody) JsNode() *Node           { return n.Node }
func (n TsNamespaceExportDecl) JsNode() *Node     { return n.Node }
func (n TsNamespaceName) JsNode() *Node           { return n.Node }
func (n TsNonNull) JsNode() *Node                 { return n.Node }
func (n TsNonNullableType) JsNode() *Node         { return n.Node }
func (n TsNullableType) JsNode() *Node            { return n.Node }
func (n TsObjectType) JsNode() *Node              { return n.Node }
func (n TsOptional) JsNode() *Node                { return n.Node }
func (n TsOverride) JsNode() *Node                { return n.Node }
func (n TsParenthesizedType) JsNode() *Node       { return n.Node }
func (n TsPredefinedType) JsNode() *Node          { return n.Node }
func (n TsPropertySignature) JsNode() *Node       { return n.Node }
func (n TsReadonly) JsNode() *Node                { return n.Node }
func (n TsReadonlyType) JsNode() *Node            { return n.Node }
func (n TsRestType) JsNode() *Node                { return n.Node }
func (n TsSatisfiesExpr) JsNode() *Node           { return n.Node }
func (n TsTemplateLiteralType) JsNode() *Node     { return n.Node }
func (n TsThisParameter) JsNode() *Node           { return n.Node }
func (n TsThisType) JsNode() *Node                { return n.Node }
func (n TsTupleType) JsNode() *Node               { return n.Node }
func (n TsTypeAliasDecl) JsNode() *Node           { return n.Node }
func (n TsTypeAnnotation) JsNode() *Node          { return n.Node }
func (n TsTypeArguments) JsNode() *Node           { return n.Node }
func (n TsTypeConstraint) JsNode() *Node          { return n.Node }
func (n TsTypeName) JsNode() *Node                { return n.Node }
func (n TsTypeOf) JsNode() *Node                  { return n.Node }
func (n TsTypeOnly) JsNode() *Node                { return n.Node }
func (n TsTypeParameter) JsNode() *Node           { return n.Node }
func (n TsTypeParameters) JsNode() *Node          { return n.Node }
func (n TsTypePredicate) JsNode() *Node           { return n.Node }
func (n TsTypeQuery) JsNode() *Node               { return n.Node }
func (n TsTypeReference) JsNode() *Node           { return n.Node }
func (n TsTypeVar) JsNode() *Node                 { return n.Node }
func (n TsUnionType) JsNode() *Node               { return n.Node }
func (n TsUniqueType) JsNode() *Node              { return n.Node }
func (n UnaryExpr) JsNode() *Node                 { return n.Node }
func (n Var) JsNode() *Node                       { return n.Node }
func (n VarDecl) JsNode() *Node                   { return n.Node }
func (n VarStmt) JsNode() *Node                   { return n.Node }
func (n WhileStmt) JsNode() *Node                 { return n.Node }
func (n WithStmt) JsNode() *Node                  { return n.Node }
func (n Yield) JsNode() *Node                     { return n.Node }
func (n MultiLineComment) JsNode() *Node          { return n.Node }
func (n SingleLineComment) JsNode() *Node         { return n.Node }
func (n InvalidToken) JsNode() *Node              { return n.Node }
func (n NoSubstitutionTemplate) JsNode() *Node    { return n.Node }
func (n TemplateHead) JsNode() *Node              { return n.Node }
func (n TemplateMiddle) JsNode() *Node            { return n.Node }
func (n TemplateTail) JsNode() *Node              { return n.Node }
func (n InsertedSemicolon) JsNode() *Node         { return n.Node }
func (NilNode) JsNode() *Node                     { return nil }

type BindingPattern interface {
	JsNode
	bindingPatternNode()
}

// bindingPatternNode() ensures that only the following types can be
// assigned to BindingPattern.
func (ArrayPattern) bindingPatternNode()  {}
func (ObjectPattern) bindingPatternNode() {}
func (NilNode) bindingPatternNode()       {}

type CaseClause interface {
	JsNode
	caseClauseNode()
}

// caseClauseNode() ensures that only the following types can be
// assigned to CaseClause.
func (Case) caseClauseNode()    {}
func (Default) caseClauseNode() {}
func (NilNode) caseClauseNode() {}

type ClassElement interface {
	JsNode
	classElementNode()
}

// classElementNode() ensures that only the following types can be
// assigned to ClassElement.
func (EmptyDecl) classElementNode()         {}
func (MemberMethod) classElementNode()      {}
func (MemberVar) classElementNode()         {}
func (StaticBlock) classElementNode()       {}
func (SyntaxProblem) classElementNode()     {}
func (TsIndexMemberDecl) classElementNode() {}
func (NilNode) classElementNode()           {}

type Decl interface {
	JsNode
	declNode()
}

// declNode() ensures that only the following types can be
// assigned to Decl.
func (AsyncFunc) declNode()                 {}
func (AsyncGeneratorDeclaration) declNode() {}
func (Class) declNode()                     {}
func (ExportDefault) declNode()             {}
func (Func) declNode()                      {}
func (Generator) declNode()                 {}
func (ImportDecl) declNode()                {}
func (LexicalDecl) declNode()               {}
func (TsAmbientClass) declNode()            {}
func (TsAmbientEnum) declNode()             {}
func (TsAmbientExportDecl) declNode()       {}
func (TsAmbientFunc) declNode()             {}
func (TsAmbientGlobal) declNode()           {}
func (TsAmbientImportAlias) declNode()      {}
func (TsAmbientInterface) declNode()        {}
func (TsAmbientModule) declNode()           {}
func (TsAmbientNamespace) declNode()        {}
func (TsAmbientTypeAlias) declNode()        {}
func (TsAmbientVar) declNode()              {}
func (TsEnum) declNode()                    {}
func (TsExportAssignment) declNode()        {}
func (TsImportAliasDecl) declNode()         {}
func (TsInterface) declNode()               {}
func (TsNamespace) declNode()               {}
func (TsTypeAliasDecl) declNode()           {}
func (NilNode) declNode()                   {}

type Decorator interface {
	JsNode
	decoratorNode()
}

// decoratorNode() ensures that only the following types can be
// assigned to Decorator.
func (DecoratorCall) decoratorNode() {}
func (DecoratorExpr) decoratorNode() {}
func (NilNode) decoratorNode()       {}

type ElementPattern interface {
	JsNode
	elementPatternNode()
}

// elementPatternNode() ensures that only the following types can be
// assigned to ElementPattern.
func (ElementBinding) elementPatternNode()    {}
func (NoElement) elementPatternNode()         {}
func (SingleNameBinding) elementPatternNode() {}
func (SyntaxProblem) elementPatternNode()     {}
func (NilNode) elementPatternNode()           {}

type ExportElement interface {
	JsNode
	exportElementNode()
}

// exportElementNode() ensures that only the following types can be
// assigned to ExportElement.
func (ExportSpec) exportElementNode()    {}
func (SyntaxProblem) exportElementNode() {}
func (NilNode) exportElementNode()       {}

type Expr interface {
	JsNode
	exprNode()
}

// exprNode() ensures that only the following types can be
// assigned to Expr.
func (AdditiveExpr) exprNode()             {}
func (ArrayLiteral) exprNode()             {}
func (ArrowFunc) exprNode()                {}
func (AssignmentExpr) exprNode()           {}
func (AsyncArrowFunc) exprNode()           {}
func (AsyncFuncExpr) exprNode()            {}
func (AsyncGeneratorExpression) exprNode() {}
func (AwaitExpr) exprNode()                {}
func (BitwiseAND) exprNode()               {}
func (BitwiseOR) exprNode()                {}
func (BitwiseXOR) exprNode()               {}
func (CallExpr) exprNode()                 {}
func (ClassExpr) exprNode()                {}
func (CoalesceExpr) exprNode()             {}
func (CommaExpr) exprNode()                {}
func (ConditionalExpr) exprNode()          {}
func (EqualityExpr) exprNode()             {}
func (ExponentiationExpr) exprNode()       {}
func (FuncExpr) exprNode()                 {}
func (GeneratorExpr) exprNode()            {}
func (IdentExpr) exprNode()                {}
func (InExpr) exprNode()                   {}
func (IndexAccess) exprNode()              {}
func (InstanceOfExpr) exprNode()           {}
func (JSXElement) exprNode()               {}
func (JSXFragment) exprNode()              {}
func (Literal) exprNode()                  {}
func (LogicalAND) exprNode()               {}
func (LogicalOR) exprNode()                {}
func (MultiplicativeExpr) exprNode()       {}
func (NewExpr) exprNode()                  {}
func (NewTarget) exprNode()                {}
func (NoElement) exprNode()                {}
func (NotExpr) exprNode()                  {}
func (ObjectLiteral) exprNode()            {}
func (OptionalCallExpr) exprNode()         {}
func (OptionalIndexAccess) exprNode()      {}
func (OptionalPropertyAccess) exprNode()   {}
func (OptionalTaggedTemplate) exprNode()   {}
func (Parenthesized) exprNode()            {}
func (PostDec) exprNode()                  {}
func (PostInc) exprNode()                  {}
func (PreDec) exprNode()                   {}
func (PreInc) exprNode()                   {}
func (PropertyAccess) exprNode()           {}
func (Regexp) exprNode()                   {}
func (RelationalExpr) exprNode()           {}
func (ShiftExpr) exprNode()                {}
func (SpreadElement) exprNode()            {}
func (SuperExpr) exprNode()                {}
func (SyntaxProblem) exprNode()            {}
func (TaggedTemplate) exprNode()           {}
func (TemplateLiteral) exprNode()          {}
func (ThisExpr) exprNode()                 {}
func (TsAsConstExpr) exprNode()            {}
func (TsAsExpr) exprNode()                 {}
func (TsCastExpr) exprNode()               {}
func (TsDynamicImport) exprNode()          {}
func (TsNonNull) exprNode()                {}
func (TsSatisfiesExpr) exprNode()          {}
func (UnaryExpr) exprNode()                {}
func (Yield) exprNode()                    {}
func (NilNode) exprNode()                  {}

type IterationStmt interface {
	JsNode
	iterationStmtNode()
}

// iterationStmtNode() ensures that only the following types can be
// assigned to IterationStmt.
func (DoWhileStmt) iterationStmtNode()      {}
func (ForInStmt) iterationStmtNode()        {}
func (ForInStmtWithVar) iterationStmtNode() {}
func (ForOfStmt) iterationStmtNode()        {}
func (ForOfStmtWithVar) iterationStmtNode() {}
func (ForStmt) iterationStmtNode()          {}
func (ForStmtWithVar) iterationStmtNode()   {}
func (WhileStmt) iterationStmtNode()        {}
func (NilNode) iterationStmtNode()          {}

type JSXAttribute interface {
	JsNode
	jSXAttributeNode()
}

// jSXAttributeNode() ensures that only the following types can be
// assigned to JSXAttribute.
func (JSXNormalAttribute) jSXAttributeNode() {}
func (JSXSpreadAttribute) jSXAttributeNode() {}
func (NilNode) jSXAttributeNode()            {}

type JSXAttributeValue interface {
	JsNode
	jSXAttributeValueNode()
}

// jSXAttributeValueNode() ensures that only the following types can be
// assigned to JSXAttributeValue.
func (JSXElement) jSXAttributeValueNode()  {}
func (JSXExpr) jSXAttributeValueNode()     {}
func (JSXFragment) jSXAttributeValueNode() {}
func (JSXLiteral) jSXAttributeValueNode()  {}
func (NilNode) jSXAttributeValueNode()     {}

type JSXChild interface {
	JsNode
	jSXChildNode()
}

// jSXChildNode() ensures that only the following types can be
// assigned to JSXChild.
func (JSXElement) jSXChildNode()    {}
func (JSXExpr) jSXChildNode()       {}
func (JSXFragment) jSXChildNode()   {}
func (JSXSpreadExpr) jSXChildNode() {}
func (JSXText) jSXChildNode()       {}
func (NilNode) jSXChildNode()       {}

type MethodDefinition interface {
	JsNode
	methodDefinitionNode()
}

// methodDefinitionNode() ensures that only the following types can be
// assigned to MethodDefinition.
func (AsyncGeneratorMethod) methodDefinitionNode() {}
func (AsyncMethod) methodDefinitionNode()          {}
func (GeneratorMethod) methodDefinitionNode()      {}
func (Getter) methodDefinitionNode()               {}
func (Method) methodDefinitionNode()               {}
func (Setter) methodDefinitionNode()               {}
func (NilNode) methodDefinitionNode()              {}

type Modifier interface {
	JsNode
	modifierNode()
}

// modifierNode() ensures that only the following types can be
// assigned to Modifier.
func (Accessor) modifierNode()                {}
func (Declare) modifierNode()                 {}
func (DecoratorCall) modifierNode()           {}
func (DecoratorExpr) modifierNode()           {}
func (Static) modifierNode()                  {}
func (TsAbstract) modifierNode()              {}
func (TsAccessibilityModifier) modifierNode() {}
func (TsOverride) modifierNode()              {}
func (TsReadonly) modifierNode()              {}
func (NilNode) modifierNode()                 {}

type ModuleItem interface {
	JsNode
	moduleItemNode()
}

// moduleItemNode() ensures that only the following types can be
// assigned to ModuleItem.
func (AsyncFunc) moduleItemNode()                 {}
func (AsyncGeneratorDeclaration) moduleItemNode() {}
func (Block) moduleItemNode()                     {}
func (BreakStmt) moduleItemNode()                 {}
func (Class) moduleItemNode()                     {}
func (ContinueStmt) moduleItemNode()              {}
func (DebuggerStmt) moduleItemNode()              {}
func (DoWhileStmt) moduleItemNode()               {}
func (EmptyStmt) moduleItemNode()                 {}
func (ExportDecl) moduleItemNode()                {}
func (ExportDefault) moduleItemNode()             {}
func (ExprStmt) moduleItemNode()                  {}
func (ForInStmt) moduleItemNode()                 {}
func (ForInStmtWithVar) moduleItemNode()          {}
func (ForOfStmt) moduleItemNode()                 {}
func (ForOfStmtWithVar) moduleItemNode()          {}
func (ForStmt) moduleItemNode()                   {}
func (ForStmtWithVar) moduleItemNode()            {}
func (Func) moduleItemNode()                      {}
func (Generator) moduleItemNode()                 {}
func (IfStmt) moduleItemNode()                    {}
func (ImportDecl) moduleItemNode()                {}
func (LabelledStmt) moduleItemNode()              {}
func (LexicalDecl) moduleItemNode()               {}
func (ReturnStmt) moduleItemNode()                {}
func (SwitchStmt) moduleItemNode()                {}
func (SyntaxProblem) moduleItemNode()             {}
func (ThrowStmt) moduleItemNode()                 {}
func (TryStmt) moduleItemNode()                   {}
func (TsAmbientClass) moduleItemNode()            {}
func (TsAmbientEnum) moduleItemNode()             {}
func (TsAmbientExportDecl) moduleItemNode()       {}
func (TsAmbientFunc) moduleItemNode()             {}
func (TsAmbientGlobal) moduleItemNode()           {}
func (TsAmbientImportAlias) moduleItemNode()      {}
func (TsAmbientInterface) moduleItemNode()        {}
func (TsAmbientModule) moduleItemNode()           {}
func (TsAmbientNamespace) moduleItemNode()        {}
func (TsAmbientTypeAlias) moduleItemNode()        {}
func (TsAmbientVar) moduleItemNode()              {}
func (TsEnum) moduleItemNode()                    {}
func (TsExportAssignment) moduleItemNode()        {}
func (TsImportAliasDecl) moduleItemNode()         {}
func (TsImportRequireDecl) moduleItemNode()       {}
func (TsInterface) moduleItemNode()               {}
func (TsNamespace) moduleItemNode()               {}
func (TsNamespaceExportDecl) moduleItemNode()     {}
func (TsTypeAliasDecl) moduleItemNode()           {}
func (VarStmt) moduleItemNode()                   {}
func (WhileStmt) moduleItemNode()                 {}
func (WithStmt) moduleItemNode()                  {}
func (NilNode) moduleItemNode()                   {}

type NamedImport interface {
	JsNode
	namedImportNode()
}

// namedImportNode() ensures that only the following types can be
// assigned to NamedImport.
func (ImportSpec) namedImportNode()    {}
func (SyntaxProblem) namedImportNode() {}
func (NilNode) namedImportNode()       {}

type Parameter interface {
	JsNode
	parameterNode()
}

// parameterNode() ensures that only the following types can be
// assigned to Parameter.
func (DefaultParameter) parameterNode() {}
func (RestParameter) parameterNode()    {}
func (SyntaxProblem) parameterNode()    {}
func (TsThisParameter) parameterNode()  {}
func (NilNode) parameterNode()          {}

type PropertyDefinition interface {
	JsNode
	propertyDefinitionNode()
}

// propertyDefinitionNode() ensures that only the following types can be
// assigned to PropertyDefinition.
func (ObjectMethod) propertyDefinitionNode()      {}
func (Property) propertyDefinitionNode()          {}
func (ShorthandProperty) propertyDefinitionNode() {}
func (SpreadProperty) propertyDefinitionNode()    {}
func (SyntaxProblem) propertyDefinitionNode()     {}
func (NilNode) propertyDefinitionNode()           {}

type PropertyName interface {
	JsNode
	propertyNameNode()
}

// propertyNameNode() ensures that only the following types can be
// assigned to PropertyName.
func (ComputedPropertyName) propertyNameNode() {}
func (LiteralPropertyName) propertyNameNode()  {}
func (NilNode) propertyNameNode()              {}

type PropertyPattern interface {
	JsNode
	propertyPatternNode()
}

// propertyPatternNode() ensures that only the following types can be
// assigned to PropertyPattern.
func (PropertyBinding) propertyPatternNode()   {}
func (SingleNameBinding) propertyPatternNode() {}
func (SyntaxProblem) propertyPatternNode()     {}
func (NilNode) propertyPatternNode()           {}

type Stmt interface {
	JsNode
	stmtNode()
}

// stmtNode() ensures that only the following types can be
// assigned to Stmt.
func (Block) stmtNode()            {}
func (BreakStmt) stmtNode()        {}
func (ContinueStmt) stmtNode()     {}
func (DebuggerStmt) stmtNode()     {}
func (DoWhileStmt) stmtNode()      {}
func (EmptyStmt) stmtNode()        {}
func (ExprStmt) stmtNode()         {}
func (ForInStmt) stmtNode()        {}
func (ForInStmtWithVar) stmtNode() {}
func (ForOfStmt) stmtNode()        {}
func (ForOfStmtWithVar) stmtNode() {}
func (ForStmt) stmtNode()          {}
func (ForStmtWithVar) stmtNode()   {}
func (IfStmt) stmtNode()           {}
func (LabelledStmt) stmtNode()     {}
func (ReturnStmt) stmtNode()       {}
func (SwitchStmt) stmtNode()       {}
func (ThrowStmt) stmtNode()        {}
func (TryStmt) stmtNode()          {}
func (VarStmt) stmtNode()          {}
func (WhileStmt) stmtNode()        {}
func (WithStmt) stmtNode()         {}
func (NilNode) stmtNode()          {}

type StmtListItem interface {
	JsNode
	stmtListItemNode()
}

// stmtListItemNode() ensures that only the following types can be
// assigned to StmtListItem.
func (AsyncFunc) stmtListItemNode()                 {}
func (AsyncGeneratorDeclaration) stmtListItemNode() {}
func (Block) stmtListItemNode()                     {}
func (BreakStmt) stmtListItemNode()                 {}
func (Class) stmtListItemNode()                     {}
func (ContinueStmt) stmtListItemNode()              {}
func (DebuggerStmt) stmtListItemNode()              {}
func (DoWhileStmt) stmtListItemNode()               {}
func (EmptyStmt) stmtListItemNode()                 {}
func (ExportDefault) stmtListItemNode()             {}
func (ExprStmt) stmtListItemNode()                  {}
func (ForInStmt) stmtListItemNode()                 {}
func (ForInStmtWithVar) stmtListItemNode()          {}
func (ForOfStmt) stmtListItemNode()                 {}
func (ForOfStmtWithVar) stmtListItemNode()          {}
func (ForStmt) stmtListItemNode()                   {}
func (ForStmtWithVar) stmtListItemNode()            {}
func (Func) stmtListItemNode()                      {}
func (Generator) stmtListItemNode()                 {}
func (IfStmt) stmtListItemNode()                    {}
func (ImportDecl) stmtListItemNode()                {}
func (LabelledStmt) stmtListItemNode()              {}
func (LexicalDecl) stmtListItemNode()               {}
func (ReturnStmt) stmtListItemNode()                {}
func (SwitchStmt) stmtListItemNode()                {}
func (SyntaxProblem) stmtListItemNode()             {}
func (ThrowStmt) stmtListItemNode()                 {}
func (TryStmt) stmtListItemNode()                   {}
func (TsAmbientClass) stmtListItemNode()            {}
func (TsAmbientEnum) stmtListItemNode()             {}
func (TsAmbientExportDecl) stmtListItemNode()       {}
func (TsAmbientFunc) stmtListItemNode()             {}
func (TsAmbientGlobal) stmtListItemNode()           {}
func (TsAmbientImportAlias) stmtListItemNode()      {}
func (TsAmbientInterface) stmtListItemNode()        {}
func (TsAmbientModule) stmtListItemNode()           {}
func (TsAmbientNamespace) stmtListItemNode()        {}
func (TsAmbientTypeAlias) stmtListItemNode()        {}
func (TsAmbientVar) stmtListItemNode()              {}
func (TsEnum) stmtListItemNode()                    {}
func (TsExportAssignment) stmtListItemNode()        {}
func (TsImportAliasDecl) stmtListItemNode()         {}
func (TsInterface) stmtListItemNode()               {}
func (TsNamespace) stmtListItemNode()               {}
func (TsTypeAliasDecl) stmtListItemNode()           {}
func (VarStmt) stmtListItemNode()                   {}
func (WhileStmt) stmtListItemNode()                 {}
func (WithStmt) stmtListItemNode()                  {}
func (NilNode) stmtListItemNode()                   {}

type TokenSet interface {
	JsNode
	tokenSetNode()
}

// tokenSetNode() ensures that only the following types can be
// assigned to TokenSet.
func (NoSubstitutionTemplate) tokenSetNode() {}
func (TemplateHead) tokenSetNode()           {}
func (TemplateMiddle) tokenSetNode()         {}
func (TemplateTail) tokenSetNode()           {}

type TsAmbientElement interface {
	JsNode
	tsAmbientElementNode()
}

// tsAmbientElementNode() ensures that only the following types can be
// assigned to TsAmbientElement.
func (ExportDefault) tsAmbientElementNode()        {}
func (ImportDecl) tsAmbientElementNode()           {}
func (TsAmbientClass) tsAmbientElementNode()       {}
func (TsAmbientEnum) tsAmbientElementNode()        {}
func (TsAmbientExportDecl) tsAmbientElementNode()  {}
func (TsAmbientFunc) tsAmbientElementNode()        {}
func (TsAmbientGlobal) tsAmbientElementNode()      {}
func (TsAmbientImportAlias) tsAmbientElementNode() {}
func (TsAmbientInterface) tsAmbientElementNode()   {}
func (TsAmbientModule) tsAmbientElementNode()      {}
func (TsAmbientNamespace) tsAmbientElementNode()   {}
func (TsAmbientTypeAlias) tsAmbientElementNode()   {}
func (TsAmbientVar) tsAmbientElementNode()         {}
func (TsExportAssignment) tsAmbientElementNode()   {}
func (NilNode) tsAmbientElementNode()              {}

type TsType interface {
	JsNode
	tsTypeNode()
}

// tsTypeNode() ensures that only the following types can be
// assigned to TsType.
func (TsArrayType) tsTypeNode()         {}
func (TsAssertsType) tsTypeNode()       {}
func (TsConditional) tsTypeNode()       {}
func (TsConstructorType) tsTypeNode()   {}
func (TsFuncType) tsTypeNode()          {}
func (TsImportType) tsTypeNode()        {}
func (TsIndexedAccessType) tsTypeNode() {}
func (TsIntersectionType) tsTypeNode()  {}
func (TsKeyOfType) tsTypeNode()         {}
func (TsLiteralType) tsTypeNode()       {}
func (TsMappedType) tsTypeNode()        {}
func (TsNonNullableType) tsTypeNode()   {}
func (TsNullableType) tsTypeNode()      {}
func (TsObjectType) tsTypeNode()        {}
func (TsParenthesizedType) tsTypeNode() {}
func (TsPredefinedType) tsTypeNode()    {}
func (TsReadonlyType) tsTypeNode()      {}
func (TsRestType) tsTypeNode()          {}
func (TsThisType) tsTypeNode()          {}
func (TsTupleType) tsTypeNode()         {}
func (TsTypePredicate) tsTypeNode()     {}
func (TsTypeQuery) tsTypeNode()         {}
func (TsTypeReference) tsTypeNode()     {}
func (TsTypeVar) tsTypeNode()           {}
func (TsUnionType) tsTypeNode()         {}
func (TsUniqueType) tsTypeNode()        {}
func (NilNode) tsTypeNode()             {}

type TsTypeMember interface {
	JsNode
	tsTypeMemberNode()
}

// tsTypeMemberNode() ensures that only the following types can be
// assigned to TsTypeMember.
func (Getter) tsTypeMemberNode()               {}
func (Setter) tsTypeMemberNode()               {}
func (SyntaxProblem) tsTypeMemberNode()        {}
func (TsCallSignature) tsTypeMemberNode()      {}
func (TsConstructSignature) tsTypeMemberNode() {}
func (TsIndexSignature) tsTypeMemberNode()     {}
func (TsMethodSignature) tsTypeMemberNode()    {}
func (TsPropertySignature) tsTypeMemberNode()  {}
func (NilNode) tsTypeMemberNode()              {}

type TupleMember interface {
	JsNode
	tupleMemberNode()
}

// tupleMemberNode() ensures that only the following types can be
// assigned to TupleMember.
func (NamedTupleMember) tupleMemberNode()    {}
func (TsArrayType) tupleMemberNode()         {}
func (TsAssertsType) tupleMemberNode()       {}
func (TsConditional) tupleMemberNode()       {}
func (TsConstructorType) tupleMemberNode()   {}
func (TsFuncType) tupleMemberNode()          {}
func (TsImportType) tupleMemberNode()        {}
func (TsIndexedAccessType) tupleMemberNode() {}
func (TsIntersectionType) tupleMemberNode()  {}
func (TsKeyOfType) tupleMemberNode()         {}
func (TsLiteralType) tupleMemberNode()       {}
func (TsMappedType) tupleMemberNode()        {}
func (TsNonNullableType) tupleMemberNode()   {}
func (TsNullableType) tupleMemberNode()      {}
func (TsObjectType) tupleMemberNode()        {}
func (TsParenthesizedType) tupleMemberNode() {}
func (TsPredefinedType) tupleMemberNode()    {}
func (TsReadonlyType) tupleMemberNode()      {}
func (TsRestType) tupleMemberNode()          {}
func (TsThisType) tupleMemberNode()          {}
func (TsTupleType) tupleMemberNode()         {}
func (TsTypePredicate) tupleMemberNode()     {}
func (TsTypeQuery) tupleMemberNode()         {}
func (TsTypeReference) tupleMemberNode()     {}
func (TsTypeVar) tupleMemberNode()           {}
func (TsUnionType) tupleMemberNode()         {}
func (TsUniqueType) tupleMemberNode()        {}
func (NilNode) tupleMemberNode()             {}

// Types.

type Accessor struct {
	*Node
}

type AdditiveExpr struct {
	*Node
}

func (n AdditiveExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n AdditiveExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Arguments struct {
	*Node
}

func (n Arguments) TsTypeArguments() (TsTypeArguments, bool) {
	child := n.Child(selector.TsTypeArguments)
	return TsTypeArguments{child}, child.IsValid()
}

func (n Arguments) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type ArrayLiteral struct {
	*Node
}

func (n ArrayLiteral) List() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type ArrayPattern struct {
	*Node
}

var selectorArrayPatternList = selector.OneOf(js.AdditiveExpr, js.ArrayLiteral, js.ArrowFunc, js.AssignmentExpr, js.AsyncArrowFunc, js.AsyncFuncExpr, js.AsyncGeneratorExpression, js.AwaitExpr, js.BitwiseAND, js.BitwiseOR, js.BitwiseXOR, js.CallExpr, js.ClassExpr, js.CoalesceExpr, js.CommaExpr, js.ConditionalExpr, js.ElementBinding, js.EqualityExpr, js.ExponentiationExpr, js.FuncExpr, js.GeneratorExpr, js.IdentExpr, js.InExpr, js.IndexAccess, js.InstanceOfExpr, js.JSXElement, js.JSXFragment, js.Literal, js.LogicalAND, js.LogicalOR, js.MultiplicativeExpr, js.NewExpr, js.NewTarget, js.NoElement, js.NotExpr, js.ObjectLiteral, js.OptionalCallExpr, js.OptionalIndexAccess, js.OptionalPropertyAccess, js.OptionalTaggedTemplate, js.Parenthesized, js.PostDec, js.PostInc, js.PreDec, js.PreInc, js.PropertyAccess, js.Regexp, js.RelationalExpr, js.ShiftExpr, js.SingleNameBinding, js.SpreadElement, js.SuperExpr, js.SyntaxProblem, js.TaggedTemplate, js.TemplateLiteral, js.ThisExpr, js.TsAsConstExpr, js.TsAsExpr, js.TsCastExpr, js.TsDynamicImport, js.TsNonNull, js.TsSatisfiesExpr, js.UnaryExpr, js.Yield)

func (n ArrayPattern) List() []JsNode {
	nodes := n.Children(selectorArrayPatternList)
	var ret = make([]JsNode, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JsNode))
	}
	return ret
}

func (n ArrayPattern) BindingRestElement() (BindingRestElement, bool) {
	child := n.Child(selector.BindingRestElement)
	return BindingRestElement{child}, child.IsValid()
}

type ArrowFunc struct {
	*Node
}

func (n ArrowFunc) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n ArrowFunc) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n ArrowFunc) Parameters() (Parameters, bool) {
	child := n.Child(selector.Parameters)
	return Parameters{child}, child.IsValid()
}

func (n ArrowFunc) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n ArrowFunc) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

func (n ArrowFunc) ConciseBody() (ConciseBody, bool) {
	child := n.Child(selector.ConciseBody)
	return ConciseBody{child}, child.IsValid()
}

func (n ArrowFunc) SyntaxProblem() (SyntaxProblem, bool) {
	child := n.Child(selector.SyntaxProblem)
	return SyntaxProblem{child}, child.IsValid()
}

type AssertClause struct {
	*Node
}

func (n AssertClause) AssertEntry() []AssertEntry {
	nodes := n.Children(selector.AssertEntry)
	var ret = make([]AssertEntry, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, AssertEntry{node})
	}
	return ret
}

type AssertEntry struct {
	*Node
}

func (n AssertEntry) AssertionKey() AssertionKey {
	child := n.Child(selector.AssertionKey)
	return AssertionKey{child}
}

type AssertionKey struct {
	*Node
}

type AssignmentExpr struct {
	*Node
}

func (n AssignmentExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n AssignmentExpr) AssignmentOperator() (AssignmentOperator, bool) {
	child := n.Child(selector.AssignmentOperator)
	return AssignmentOperator{child}, child.IsValid()
}

func (n AssignmentExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type AssignmentOperator struct {
	*Node
}

type AsyncArrowFunc struct {
	*Node
}

func (n AsyncArrowFunc) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n AsyncArrowFunc) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncArrowFunc) Parameters() (Parameters, bool) {
	child := n.Child(selector.Parameters)
	return Parameters{child}, child.IsValid()
}

func (n AsyncArrowFunc) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncArrowFunc) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

func (n AsyncArrowFunc) ConciseBody() (ConciseBody, bool) {
	child := n.Child(selector.ConciseBody)
	return ConciseBody{child}, child.IsValid()
}

type AsyncFunc struct {
	*Node
}

func (n AsyncFunc) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n AsyncFunc) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncFunc) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncFunc) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncFunc) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type AsyncFuncExpr struct {
	*Node
}

func (n AsyncFuncExpr) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n AsyncFuncExpr) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncFuncExpr) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncFuncExpr) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncFuncExpr) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type AsyncGeneratorDeclaration struct {
	*Node
}

func (n AsyncGeneratorDeclaration) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n AsyncGeneratorDeclaration) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncGeneratorDeclaration) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncGeneratorDeclaration) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncGeneratorDeclaration) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type AsyncGeneratorExpression struct {
	*Node
}

func (n AsyncGeneratorExpression) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n AsyncGeneratorExpression) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncGeneratorExpression) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncGeneratorExpression) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncGeneratorExpression) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type AsyncGeneratorMethod struct {
	*Node
}

func (n AsyncGeneratorMethod) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n AsyncGeneratorMethod) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncGeneratorMethod) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncGeneratorMethod) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncGeneratorMethod) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type AsyncMethod struct {
	*Node
}

func (n AsyncMethod) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n AsyncMethod) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n AsyncMethod) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n AsyncMethod) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n AsyncMethod) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type Await struct {
	*Node
}

type AwaitExpr struct {
	*Node
}

func (n AwaitExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type BindingRestElement struct {
	*Node
}

func (n BindingRestElement) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type BitwiseAND struct {
	*Node
}

func (n BitwiseAND) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n BitwiseAND) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type BitwiseOR struct {
	*Node
}

func (n BitwiseOR) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n BitwiseOR) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type BitwiseXOR struct {
	*Node
}

func (n BitwiseXOR) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n BitwiseXOR) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Block struct {
	*Node
}

func (n Block) CaseClause() []CaseClause {
	nodes := n.Children(selector.CaseClause)
	var ret = make([]CaseClause, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(CaseClause))
	}
	return ret
}

func (n Block) List() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type Body struct {
	*Node
}

func (n Body) List() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type BreakStmt struct {
	*Node
}

func (n BreakStmt) LabelIdent() (LabelIdent, bool) {
	child := n.Child(selector.LabelIdent)
	return LabelIdent{child}, child.IsValid()
}

type CallExpr struct {
	*Node
}

func (n CallExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n CallExpr) Arguments() Arguments {
	child := n.Child(selector.Arguments)
	return Arguments{child}
}

type Case struct {
	*Node
}

func (n Case) Cond() Cond {
	child := n.Child(selector.Cond)
	return Cond{child}
}

func (n Case) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type Catch struct {
	*Node
}

func (n Catch) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n Catch) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n Catch) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n Catch) Block() Block {
	child := n.Child(selector.Block)
	return Block{child}
}

type Class struct {
	*Node
}

func (n Class) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Class) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n Class) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n Class) Extends() (Extends, bool) {
	child := n.Child(selector.Extends)
	return Extends{child}, child.IsValid()
}

func (n Class) TsImplementsClause() (TsImplementsClause, bool) {
	child := n.Child(selector.TsImplementsClause)
	return TsImplementsClause{child}, child.IsValid()
}

func (n Class) ClassBody() ClassBody {
	child := n.Child(selector.ClassBody)
	return ClassBody{child}
}

type ClassBody struct {
	*Node
}

func (n ClassBody) ClassElement() []ClassElement {
	nodes := n.Children(selector.ClassElement)
	var ret = make([]ClassElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ClassElement))
	}
	return ret
}

type ClassExpr struct {
	*Node
}

func (n ClassExpr) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ClassExpr) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n ClassExpr) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n ClassExpr) Extends() (Extends, bool) {
	child := n.Child(selector.Extends)
	return Extends{child}, child.IsValid()
}

func (n ClassExpr) TsImplementsClause() (TsImplementsClause, bool) {
	child := n.Child(selector.TsImplementsClause)
	return TsImplementsClause{child}, child.IsValid()
}

func (n ClassExpr) ClassBody() ClassBody {
	child := n.Child(selector.ClassBody)
	return ClassBody{child}
}

type CoalesceExpr struct {
	*Node
}

func (n CoalesceExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n CoalesceExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type CommaExpr struct {
	*Node
}

func (n CommaExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n CommaExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ComputedPropertyName struct {
	*Node
}

func (n ComputedPropertyName) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ConciseBody struct {
	*Node
}

func (n ConciseBody) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Cond struct {
	*Node
}

func (n Cond) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ConditionalExpr struct {
	*Node
}

func (n ConditionalExpr) Cond() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ConditionalExpr) Then() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ConditionalExpr) Else() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ContinueStmt struct {
	*Node
}

func (n ContinueStmt) LabelIdent() (LabelIdent, bool) {
	child := n.Child(selector.LabelIdent)
	return LabelIdent{child}, child.IsValid()
}

type DebuggerStmt struct {
	*Node
}

type Declare struct {
	*Node
}

type DecoratorCall struct {
	*Node
}

func (n DecoratorCall) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

func (n DecoratorCall) Arguments() Arguments {
	child := n.Child(selector.Arguments)
	return Arguments{child}
}

type DecoratorExpr struct {
	*Node
}

func (n DecoratorExpr) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type Default struct {
	*Node
}

func (n Default) StmtListItem() []StmtListItem {
	nodes := n.Children(selector.StmtListItem)
	var ret = make([]StmtListItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(StmtListItem))
	}
	return ret
}

type DefaultParameter struct {
	*Node
}

func (n DefaultParameter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n DefaultParameter) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n DefaultParameter) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n DefaultParameter) TsOptional() (TsOptional, bool) {
	child := n.Child(selector.TsOptional)
	return TsOptional{child}, child.IsValid()
}

func (n DefaultParameter) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n DefaultParameter) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type DoWhileStmt struct {
	*Node
}

func (n DoWhileStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

func (n DoWhileStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ElementBinding struct {
	*Node
}

func (n ElementBinding) BindingPattern() BindingPattern {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern)
}

func (n ElementBinding) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type EmptyDecl struct {
	*Node
}

type EmptyStmt struct {
	*Node
}

type EqualityExpr struct {
	*Node
}

func (n EqualityExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n EqualityExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ExponentiationExpr struct {
	*Node
}

func (n ExponentiationExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ExponentiationExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ExportClause struct {
	*Node
}

func (n ExportClause) ExportElement() []ExportElement {
	nodes := n.Children(selector.ExportElement)
	var ret = make([]ExportElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ExportElement))
	}
	return ret
}

type ExportDecl struct {
	*Node
}

func (n ExportDecl) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	child := n.Child(selector.TsTypeOnly)
	return TsTypeOnly{child}, child.IsValid()
}

func (n ExportDecl) VarStmt() (VarStmt, bool) {
	child := n.Child(selector.VarStmt)
	return VarStmt{child}, child.IsValid()
}

func (n ExportDecl) Decl() (Decl, bool) {
	child := n.Child(selector.Decl)
	return ToJsNode(child).(Decl), child.IsValid()
}

func (n ExportDecl) ExportClause() (ExportClause, bool) {
	child := n.Child(selector.ExportClause)
	return ExportClause{child}, child.IsValid()
}

func (n ExportDecl) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n ExportDecl) ModuleSpec() (ModuleSpec, bool) {
	child := n.Child(selector.ModuleSpec)
	return ModuleSpec{child}, child.IsValid()
}

func (n ExportDecl) AssertClause() (AssertClause, bool) {
	child := n.Child(selector.AssertClause)
	return AssertClause{child}, child.IsValid()
}

type ExportDefault struct {
	*Node
}

func (n ExportDefault) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

func (n ExportDefault) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ExportDefault) Decl() (Decl, bool) {
	child := n.Child(selector.Decl)
	return ToJsNode(child).(Decl), child.IsValid()
}

type ExportSpec struct {
	*Node
}

func (n ExportSpec) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

func (n ExportSpec) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type ExprStmt struct {
	*Node
}

func (n ExprStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Extends struct {
	*Node
}

func (n Extends) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

func (n Extends) TsTypeReference() (TsTypeReference, bool) {
	child := n.Child(selector.TsTypeReference)
	return TsTypeReference{child}, child.IsValid()
}

type Finally struct {
	*Node
}

func (n Finally) Block() Block {
	child := n.Child(selector.Block)
	return Block{child}
}

type ForBinding struct {
	*Node
}

func (n ForBinding) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n ForBinding) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

type ForCondition struct {
	*Node
}

func (n ForCondition) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type ForFinalExpr struct {
	*Node
}

func (n ForFinalExpr) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type ForInStmt struct {
	*Node
}

func (n ForInStmt) Var() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForInStmt) Object() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForInStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type ForInStmtWithVar struct {
	*Node
}

func (n ForInStmtWithVar) LetOrConst() (LetOrConst, bool) {
	child := n.Child(selector.LetOrConst)
	return LetOrConst{child}, child.IsValid()
}

func (n ForInStmtWithVar) Var() (Var, bool) {
	child := n.Child(selector.Var)
	return Var{child}, child.IsValid()
}

func (n ForInStmtWithVar) ForBinding() ForBinding {
	child := n.Child(selector.ForBinding)
	return ForBinding{child}
}

func (n ForInStmtWithVar) Object() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForInStmtWithVar) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type ForOfStmt struct {
	*Node
}

func (n ForOfStmt) Await() (Await, bool) {
	child := n.Child(selector.Await)
	return Await{child}, child.IsValid()
}

func (n ForOfStmt) Var() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForOfStmt) Iterable() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForOfStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type ForOfStmtWithVar struct {
	*Node
}

func (n ForOfStmtWithVar) Await() (Await, bool) {
	child := n.Child(selector.Await)
	return Await{child}, child.IsValid()
}

func (n ForOfStmtWithVar) LetOrConst() (LetOrConst, bool) {
	child := n.Child(selector.LetOrConst)
	return LetOrConst{child}, child.IsValid()
}

func (n ForOfStmtWithVar) Var() (Var, bool) {
	child := n.Child(selector.Var)
	return Var{child}, child.IsValid()
}

func (n ForOfStmtWithVar) ForBinding() ForBinding {
	child := n.Child(selector.ForBinding)
	return ForBinding{child}
}

func (n ForOfStmtWithVar) Iterable() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ForOfStmtWithVar) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type ForStmt struct {
	*Node
}

func (n ForStmt) Var() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

func (n ForStmt) ForCondition() ForCondition {
	child := n.Child(selector.ForCondition)
	return ForCondition{child}
}

func (n ForStmt) ForFinalExpr() ForFinalExpr {
	child := n.Child(selector.ForFinalExpr)
	return ForFinalExpr{child}
}

func (n ForStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type ForStmtWithVar struct {
	*Node
}

func (n ForStmtWithVar) LetOrConst() (LetOrConst, bool) {
	child := n.Child(selector.LetOrConst)
	return LetOrConst{child}, child.IsValid()
}

func (n ForStmtWithVar) Var() (Var, bool) {
	child := n.Child(selector.Var)
	return Var{child}, child.IsValid()
}

func (n ForStmtWithVar) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

func (n ForStmtWithVar) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

func (n ForStmtWithVar) ForCondition() ForCondition {
	child := n.Child(selector.ForCondition)
	return ForCondition{child}
}

func (n ForStmtWithVar) ForFinalExpr() ForFinalExpr {
	child := n.Child(selector.ForFinalExpr)
	return ForFinalExpr{child}
}

func (n ForStmtWithVar) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type Func struct {
	*Node
}

func (n Func) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n Func) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n Func) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n Func) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n Func) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type FuncExpr struct {
	*Node
}

func (n FuncExpr) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n FuncExpr) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n FuncExpr) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n FuncExpr) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n FuncExpr) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type Generator struct {
	*Node
}

func (n Generator) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n Generator) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n Generator) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n Generator) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n Generator) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type GeneratorExpr struct {
	*Node
}

func (n GeneratorExpr) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n GeneratorExpr) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n GeneratorExpr) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n GeneratorExpr) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n GeneratorExpr) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type GeneratorMethod struct {
	*Node
}

func (n GeneratorMethod) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n GeneratorMethod) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n GeneratorMethod) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n GeneratorMethod) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n GeneratorMethod) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type Getter struct {
	*Node
}

func (n Getter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Getter) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n Getter) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n Getter) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type IdentExpr struct {
	*Node
}

func (n IdentExpr) ReferenceIdent() ReferenceIdent {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}
}

type IfStmt struct {
	*Node
}

func (n IfStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n IfStmt) Then() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

func (n IfStmt) Else() (Stmt, bool) {
	child := n.Child(selector.Stmt).Next(selector.Stmt)
	return ToJsNode(child).(Stmt), child.IsValid()
}

type ImportDecl struct {
	*Node
}

func (n ImportDecl) TsTypeOnly() (TsTypeOnly, bool) {
	child := n.Child(selector.TsTypeOnly)
	return TsTypeOnly{child}, child.IsValid()
}

func (n ImportDecl) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n ImportDecl) NameSpaceImport() (NameSpaceImport, bool) {
	child := n.Child(selector.NameSpaceImport)
	return NameSpaceImport{child}, child.IsValid()
}

func (n ImportDecl) NamedImports() (NamedImports, bool) {
	child := n.Child(selector.NamedImports)
	return NamedImports{child}, child.IsValid()
}

func (n ImportDecl) ModuleSpec() ModuleSpec {
	child := n.Child(selector.ModuleSpec)
	return ModuleSpec{child}
}

func (n ImportDecl) AssertClause() (AssertClause, bool) {
	child := n.Child(selector.AssertClause)
	return AssertClause{child}, child.IsValid()
}

type ImportSpec struct {
	*Node
}

func (n ImportSpec) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

func (n ImportSpec) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type InExpr struct {
	*Node
}

func (n InExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n InExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type IndexAccess struct {
	*Node
}

func (n IndexAccess) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n IndexAccess) Index() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Initializer struct {
	*Node
}

func (n Initializer) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type InstanceOfExpr struct {
	*Node
}

func (n InstanceOfExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n InstanceOfExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type JSXAttributeName struct {
	*Node
}

type JSXClosingElement struct {
	*Node
}

func (n JSXClosingElement) JSXElementName() JSXElementName {
	child := n.Child(selector.JSXElementName)
	return JSXElementName{child}
}

type JSXElement struct {
	*Node
}

func (n JSXElement) JSXOpeningElement() (JSXOpeningElement, bool) {
	child := n.Child(selector.JSXOpeningElement)
	return JSXOpeningElement{child}, child.IsValid()
}

func (n JSXElement) JSXSelfClosingElement() (JSXSelfClosingElement, bool) {
	child := n.Child(selector.JSXSelfClosingElement)
	return JSXSelfClosingElement{child}, child.IsValid()
}

func (n JSXElement) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var ret = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXChild))
	}
	return ret
}

func (n JSXElement) JSXClosingElement() (JSXClosingElement, bool) {
	child := n.Child(selector.JSXClosingElement)
	return JSXClosingElement{child}, child.IsValid()
}

type JSXElementName struct {
	*Node
}

type JSXExpr struct {
	*Node
}

func (n JSXExpr) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type JSXFragment struct {
	*Node
}

func (n JSXFragment) JSXChild() []JSXChild {
	nodes := n.Children(selector.JSXChild)
	var ret = make([]JSXChild, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXChild))
	}
	return ret
}

type JSXLiteral struct {
	*Node
}

type JSXNormalAttribute struct {
	*Node
}

func (n JSXNormalAttribute) JSXAttributeName() JSXAttributeName {
	child := n.Child(selector.JSXAttributeName)
	return JSXAttributeName{child}
}

func (n JSXNormalAttribute) JSXAttributeValue() (JSXAttributeValue, bool) {
	child := n.Child(selector.JSXAttributeValue)
	return ToJsNode(child).(JSXAttributeValue), child.IsValid()
}

type JSXOpeningElement struct {
	*Node
}

func (n JSXOpeningElement) JSXElementName() JSXElementName {
	child := n.Child(selector.JSXElementName)
	return JSXElementName{child}
}

func (n JSXOpeningElement) TsTypeArguments() (TsTypeArguments, bool) {
	child := n.Child(selector.TsTypeArguments)
	return TsTypeArguments{child}, child.IsValid()
}

func (n JSXOpeningElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSelfClosingElement struct {
	*Node
}

func (n JSXSelfClosingElement) JSXElementName() JSXElementName {
	child := n.Child(selector.JSXElementName)
	return JSXElementName{child}
}

func (n JSXSelfClosingElement) TsTypeArguments() (TsTypeArguments, bool) {
	child := n.Child(selector.TsTypeArguments)
	return TsTypeArguments{child}, child.IsValid()
}

func (n JSXSelfClosingElement) JSXAttribute() []JSXAttribute {
	nodes := n.Children(selector.JSXAttribute)
	var ret = make([]JSXAttribute, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JSXAttribute))
	}
	return ret
}

type JSXSpreadAttribute struct {
	*Node
}

func (n JSXSpreadAttribute) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type JSXSpreadExpr struct {
	*Node
}

func (n JSXSpreadExpr) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type JSXText struct {
	*Node
}

type LabelIdent struct {
	*Node
}

type LabelledStmt struct {
	*Node
}

func (n LabelledStmt) LabelIdent() LabelIdent {
	child := n.Child(selector.LabelIdent)
	return LabelIdent{child}
}

func (n LabelledStmt) Func() (Func, bool) {
	child := n.Child(selector.Func)
	return Func{child}, child.IsValid()
}

func (n LabelledStmt) Stmt() (Stmt, bool) {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt), child.IsValid()
}

type LetOrConst struct {
	*Node
}

type LexicalBinding struct {
	*Node
}

func (n LexicalBinding) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n LexicalBinding) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n LexicalBinding) TsExclToken() (TsExclToken, bool) {
	child := n.Child(selector.TsExclToken)
	return TsExclToken{child}, child.IsValid()
}

func (n LexicalBinding) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n LexicalBinding) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type LexicalDecl struct {
	*Node
}

func (n LexicalDecl) LetOrConst() LetOrConst {
	child := n.Child(selector.LetOrConst)
	return LetOrConst{child}
}

func (n LexicalDecl) LexicalBinding() []LexicalBinding {
	nodes := n.Children(selector.LexicalBinding)
	var ret = make([]LexicalBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, LexicalBinding{node})
	}
	return ret
}

type Literal struct {
	*Node
}

type LiteralPropertyName struct {
	*Node
}

func (n LiteralPropertyName) Literal() (Literal, bool) {
	child := n.Child(selector.Literal)
	return Literal{child}, child.IsValid()
}

func (n LiteralPropertyName) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

type LogicalAND struct {
	*Node
}

func (n LogicalAND) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n LogicalAND) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type LogicalOR struct {
	*Node
}

func (n LogicalOR) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n LogicalOR) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type MemberMethod struct {
	*Node
}

func (n MemberMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberMethod) MethodDefinition() MethodDefinition {
	child := n.Child(selector.MethodDefinition)
	return ToJsNode(child).(MethodDefinition)
}

type MemberVar struct {
	*Node
}

func (n MemberVar) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n MemberVar) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n MemberVar) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n MemberVar) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type Method struct {
	*Node
}

func (n Method) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n Method) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n Method) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n Method) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n Method) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type Module struct {
	*Node
}

func (n Module) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type ModuleSpec struct {
	*Node
}

type MultiplicativeExpr struct {
	*Node
}

func (n MultiplicativeExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n MultiplicativeExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type NameIdent struct {
	*Node
}

func (n NameIdent) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

type NameSpaceImport struct {
	*Node
}

func (n NameSpaceImport) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type NamedImports struct {
	*Node
}

func (n NamedImports) NamedImport() []NamedImport {
	nodes := n.Children(selector.NamedImport)
	var ret = make([]NamedImport, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(NamedImport))
	}
	return ret
}

type NamedTupleMember struct {
	*Node
}

func (n NamedTupleMember) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type NewExpr struct {
	*Node
}

func (n NewExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n NewExpr) Arguments() (Arguments, bool) {
	child := n.Child(selector.Arguments)
	return Arguments{child}, child.IsValid()
}

type NewTarget struct {
	*Node
}

type NoElement struct {
	*Node
}

type NotExpr struct {
	*Node
}

func (n NotExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ObjectLiteral struct {
	*Node
}

func (n ObjectLiteral) PropertyDefinition() []PropertyDefinition {
	nodes := n.Children(selector.PropertyDefinition)
	var ret = make([]PropertyDefinition, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyDefinition))
	}
	return ret
}

type ObjectMethod struct {
	*Node
}

func (n ObjectMethod) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n ObjectMethod) MethodDefinition() MethodDefinition {
	child := n.Child(selector.MethodDefinition)
	return ToJsNode(child).(MethodDefinition)
}

type ObjectPattern struct {
	*Node
}

func (n ObjectPattern) PropertyPattern() []PropertyPattern {
	nodes := n.Children(selector.PropertyPattern)
	var ret = make([]PropertyPattern, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(PropertyPattern))
	}
	return ret
}

func (n ObjectPattern) BindingRestElement() (BindingRestElement, bool) {
	child := n.Child(selector.BindingRestElement)
	return BindingRestElement{child}, child.IsValid()
}

type OptionalCallExpr struct {
	*Node
}

func (n OptionalCallExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n OptionalCallExpr) Arguments() Arguments {
	child := n.Child(selector.Arguments)
	return Arguments{child}
}

type OptionalIndexAccess struct {
	*Node
}

func (n OptionalIndexAccess) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n OptionalIndexAccess) Index() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type OptionalPropertyAccess struct {
	*Node
}

func (n OptionalPropertyAccess) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n OptionalPropertyAccess) Selector() ReferenceIdent {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}
}

type OptionalTaggedTemplate struct {
	*Node
}

func (n OptionalTaggedTemplate) Tag() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n OptionalTaggedTemplate) Literal() TemplateLiteral {
	child := n.Child(selector.Expr).Next(selector.TemplateLiteral)
	return TemplateLiteral{child}
}

type Parameters struct {
	*Node
}

func (n Parameters) Parameter() []Parameter {
	nodes := n.Children(selector.Parameter)
	var ret = make([]Parameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Parameter))
	}
	return ret
}

type Parenthesized struct {
	*Node
}

func (n Parenthesized) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type PostDec struct {
	*Node
}

func (n PostDec) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type PostInc struct {
	*Node
}

func (n PostInc) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type PreDec struct {
	*Node
}

func (n PreDec) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type PreInc struct {
	*Node
}

func (n PreInc) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Property struct {
	*Node
}

func (n Property) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Property) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n Property) Value() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type PropertyAccess struct {
	*Node
}

func (n PropertyAccess) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

func (n PropertyAccess) Selector() ReferenceIdent {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}
}

type PropertyBinding struct {
	*Node
}

func (n PropertyBinding) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n PropertyBinding) ElementPattern() ElementPattern {
	child := n.Child(selector.ElementPattern)
	return ToJsNode(child).(ElementPattern)
}

type ReferenceIdent struct {
	*Node
}

type Regexp struct {
	*Node
}

type RelationalExpr struct {
	*Node
}

func (n RelationalExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n RelationalExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type RestParameter struct {
	*Node
}

func (n RestParameter) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n RestParameter) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n RestParameter) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type ReturnStmt struct {
	*Node
}

func (n ReturnStmt) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type Setter struct {
	*Node
}

func (n Setter) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n Setter) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n Setter) Parameter() Parameter {
	child := n.Child(selector.Parameter)
	return ToJsNode(child).(Parameter)
}

func (n Setter) Body() (Body, bool) {
	child := n.Child(selector.Body)
	return Body{child}, child.IsValid()
}

type ShiftExpr struct {
	*Node
}

func (n ShiftExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n ShiftExpr) Right() Expr {
	child := n.Child(selector.Expr).Next(selector.Expr)
	return ToJsNode(child).(Expr)
}

type ShorthandProperty struct {
	*Node
}

func (n ShorthandProperty) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type SingleNameBinding struct {
	*Node
}

func (n SingleNameBinding) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n SingleNameBinding) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type SpreadElement struct {
	*Node
}

func (n SpreadElement) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type SpreadProperty struct {
	*Node
}

func (n SpreadProperty) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Static struct {
	*Node
}

type StaticBlock struct {
	*Node
}

func (n StaticBlock) Body() Body {
	child := n.Child(selector.Body)
	return Body{child}
}

type SuperExpr struct {
	*Node
}

func (n SuperExpr) ReferenceIdent() ReferenceIdent {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}
}

type SwitchStmt struct {
	*Node
}

func (n SwitchStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n SwitchStmt) Block() Block {
	child := n.Child(selector.Block)
	return Block{child}
}

type SyntaxProblem struct {
	*Node
}

func (n SyntaxProblem) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

func (n SyntaxProblem) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type TaggedTemplate struct {
	*Node
}

func (n TaggedTemplate) Tag() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n TaggedTemplate) Literal() TemplateLiteral {
	child := n.Child(selector.Expr).Next(selector.TemplateLiteral)
	return TemplateLiteral{child}
}

type TemplateLiteral struct {
	*Node
}

var selectorTemplateLiteralTemplate = selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail)

func (n TemplateLiteral) Template() []JsNode {
	nodes := n.Children(selectorTemplateLiteralTemplate)
	var ret = make([]JsNode, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JsNode))
	}
	return ret
}

func (n TemplateLiteral) Substitution() []Expr {
	nodes := n.Children(selector.Expr)
	var ret = make([]Expr, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Expr))
	}
	return ret
}

type This struct {
	*Node
}

type ThisExpr struct {
	*Node
}

func (n ThisExpr) This() This {
	child := n.Child(selector.This)
	return This{child}
}

type ThrowStmt struct {
	*Node
}

func (n ThrowStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type TryStmt struct {
	*Node
}

func (n TryStmt) Block() Block {
	child := n.Child(selector.Block)
	return Block{child}
}

func (n TryStmt) Catch() (Catch, bool) {
	child := n.Child(selector.Catch)
	return Catch{child}, child.IsValid()
}

func (n TryStmt) Finally() (Finally, bool) {
	child := n.Child(selector.Finally)
	return Finally{child}, child.IsValid()
}

type TsAbstract struct {
	*Node
}

type TsAccessibilityModifier struct {
	*Node
}

type TsAmbientBinding struct {
	*Node
}

func (n TsAmbientBinding) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsAmbientBinding) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n TsAmbientBinding) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type TsAmbientClass struct {
	*Node
}

func (n TsAmbientClass) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientClass) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsAmbientClass) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsAmbientClass) Extends() (Extends, bool) {
	child := n.Child(selector.Extends)
	return Extends{child}, child.IsValid()
}

func (n TsAmbientClass) TsImplementsClause() (TsImplementsClause, bool) {
	child := n.Child(selector.TsImplementsClause)
	return TsImplementsClause{child}, child.IsValid()
}

func (n TsAmbientClass) ClassBody() ClassBody {
	child := n.Child(selector.ClassBody)
	return ClassBody{child}
}

type TsAmbientEnum struct {
	*Node
}

func (n TsAmbientEnum) TsConst() (TsConst, bool) {
	child := n.Child(selector.TsConst)
	return TsConst{child}, child.IsValid()
}

func (n TsAmbientEnum) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsAmbientEnum) TsEnumBody() TsEnumBody {
	child := n.Child(selector.TsEnumBody)
	return TsEnumBody{child}
}

type TsAmbientExportDecl struct {
	*Node
}

func (n TsAmbientExportDecl) ExportClause() ExportClause {
	child := n.Child(selector.ExportClause)
	return ExportClause{child}
}

type TsAmbientFunc struct {
	*Node
}

func (n TsAmbientFunc) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsAmbientFunc) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsAmbientFunc) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsAmbientFunc) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type TsAmbientGlobal struct {
	*Node
}

func (n TsAmbientGlobal) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsAmbientImportAlias struct {
	*Node
}

func (n TsAmbientImportAlias) TsImportAliasDecl() TsImportAliasDecl {
	child := n.Child(selector.TsImportAliasDecl)
	return TsImportAliasDecl{child}
}

type TsAmbientInterface struct {
	*Node
}

func (n TsAmbientInterface) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsAmbientInterface) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsAmbientInterface) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsAmbientInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	child := n.Child(selector.TsInterfaceExtends)
	return TsInterfaceExtends{child}, child.IsValid()
}

func (n TsAmbientInterface) TsObjectType() TsObjectType {
	child := n.Child(selector.TsObjectType)
	return TsObjectType{child}
}

type TsAmbientModule struct {
	*Node
}

func (n TsAmbientModule) Literal() (Literal, bool) {
	child := n.Child(selector.Literal)
	return Literal{child}, child.IsValid()
}

func (n TsAmbientModule) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientModule) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var ret = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsAmbientElement))
	}
	return ret
}

type TsAmbientNamespace struct {
	*Node
}

func (n TsAmbientNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsAmbientNamespace) TsAmbientElement() []TsAmbientElement {
	nodes := n.Children(selector.TsAmbientElement)
	var ret = make([]TsAmbientElement, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsAmbientElement))
	}
	return ret
}

type TsAmbientTypeAlias struct {
	*Node
}

func (n TsAmbientTypeAlias) TsTypeAliasDecl() TsTypeAliasDecl {
	child := n.Child(selector.TsTypeAliasDecl)
	return TsTypeAliasDecl{child}
}

type TsAmbientVar struct {
	*Node
}

func (n TsAmbientVar) LetOrConst() (LetOrConst, bool) {
	child := n.Child(selector.LetOrConst)
	return LetOrConst{child}, child.IsValid()
}

func (n TsAmbientVar) Var() (Var, bool) {
	child := n.Child(selector.Var)
	return Var{child}, child.IsValid()
}

func (n TsAmbientVar) TsAmbientBinding() []TsAmbientBinding {
	nodes := n.Children(selector.TsAmbientBinding)
	var ret = make([]TsAmbientBinding, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsAmbientBinding{node})
	}
	return ret
}

type TsArrayType struct {
	*Node
}

func (n TsArrayType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsAsConstExpr struct {
	*Node
}

func (n TsAsConstExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n TsAsConstExpr) TsConst() TsConst {
	child := n.Child(selector.TsConst)
	return TsConst{child}
}

type TsAsExpr struct {
	*Node
}

func (n TsAsExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n TsAsExpr) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsAssertsType struct {
	*Node
}

func (n TsAssertsType) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

func (n TsAssertsType) This() (This, bool) {
	child := n.Child(selector.This)
	return This{child}, child.IsValid()
}

func (n TsAssertsType) TsType() (TsType, bool) {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType), child.IsValid()
}

type TsCallSignature struct {
	*Node
}

func (n TsCallSignature) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsCallSignature) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsCallSignature) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type TsCastExpr struct {
	*Node
}

func (n TsCastExpr) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsCastExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type TsConditional struct {
	*Node
}

func (n TsConditional) Check() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsConditional) Ext() TsType {
	child := n.Child(selector.TsType).Next(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsConditional) Truet() TsType {
	child := n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsConditional) Falset() TsType {
	child := n.Child(selector.TsType).Next(selector.TsType).Next(selector.TsType).Next(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsConst struct {
	*Node
}

type TsConstructSignature struct {
	*Node
}

func (n TsConstructSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsConstructSignature) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsConstructSignature) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsConstructSignature) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type TsConstructorType struct {
	*Node
}

func (n TsConstructorType) TsAbstract() (TsAbstract, bool) {
	child := n.Child(selector.TsAbstract)
	return TsAbstract{child}, child.IsValid()
}

func (n TsConstructorType) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsConstructorType) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsConstructorType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsDynamicImport struct {
	*Node
}

func (n TsDynamicImport) Arguments() Arguments {
	child := n.Child(selector.Arguments)
	return Arguments{child}
}

type TsEnum struct {
	*Node
}

func (n TsEnum) TsConst() (TsConst, bool) {
	child := n.Child(selector.TsConst)
	return TsConst{child}, child.IsValid()
}

func (n TsEnum) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsEnum) TsEnumBody() TsEnumBody {
	child := n.Child(selector.TsEnumBody)
	return TsEnumBody{child}
}

type TsEnumBody struct {
	*Node
}

func (n TsEnumBody) TsEnumMember() []TsEnumMember {
	nodes := n.Children(selector.TsEnumMember)
	var ret = make([]TsEnumMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsEnumMember{node})
	}
	return ret
}

type TsEnumMember struct {
	*Node
}

func (n TsEnumMember) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n TsEnumMember) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type TsExclToken struct {
	*Node
}

type TsExport struct {
	*Node
}

type TsExportAssignment struct {
	*Node
}

func (n TsExportAssignment) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type TsFuncType struct {
	*Node
}

func (n TsFuncType) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsFuncType) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsFuncType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsImplementsClause struct {
	*Node
}

func (n TsImplementsClause) TsTypeReference() []TsTypeReference {
	nodes := n.Children(selector.TsTypeReference)
	var ret = make([]TsTypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsTypeReference{node})
	}
	return ret
}

type TsImportAliasDecl struct {
	*Node
}

func (n TsImportAliasDecl) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsImportAliasDecl) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsImportRequireDecl struct {
	*Node
}

func (n TsImportRequireDecl) TsExport() (TsExport, bool) {
	child := n.Child(selector.TsExport)
	return TsExport{child}, child.IsValid()
}

func (n TsImportRequireDecl) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsImportRequireDecl) ModuleSpec() ModuleSpec {
	child := n.Child(selector.ModuleSpec)
	return ModuleSpec{child}
}

type TsImportType struct {
	*Node
}

func (n TsImportType) TsImportTypeStart() TsImportTypeStart {
	child := n.Child(selector.TsImportTypeStart)
	return TsImportTypeStart{child}
}

func (n TsImportType) TsTypeArguments() (TsTypeArguments, bool) {
	child := n.Child(selector.TsTypeArguments)
	return TsTypeArguments{child}, child.IsValid()
}

type TsImportTypeStart struct {
	*Node
}

func (n TsImportTypeStart) TsImportTypeStart() (TsImportTypeStart, bool) {
	child := n.Child(selector.TsImportTypeStart)
	return TsImportTypeStart{child}, child.IsValid()
}

func (n TsImportTypeStart) TsTypeOf() (TsTypeOf, bool) {
	child := n.Child(selector.TsTypeOf)
	return TsTypeOf{child}, child.IsValid()
}

func (n TsImportTypeStart) ReferenceIdent() (ReferenceIdent, bool) {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}, child.IsValid()
}

func (n TsImportTypeStart) TsType() (TsType, bool) {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType), child.IsValid()
}

type TsIndexMemberDecl struct {
	*Node
}

func (n TsIndexMemberDecl) TsIndexSignature() TsIndexSignature {
	child := n.Child(selector.TsIndexSignature)
	return TsIndexSignature{child}
}

type TsIndexSignature struct {
	*Node
}

func (n TsIndexSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsIndexSignature) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsIndexSignature) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsIndexSignature) TsTypeAnnotation() TsTypeAnnotation {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}
}

type TsIndexedAccessType struct {
	*Node
}

func (n TsIndexedAccessType) Left() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsIndexedAccessType) Index() TsType {
	child := n.Child(selector.TsType).Next(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsInterface struct {
	*Node
}

func (n TsInterface) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsInterface) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsInterface) TsInterfaceExtends() (TsInterfaceExtends, bool) {
	child := n.Child(selector.TsInterfaceExtends)
	return TsInterfaceExtends{child}, child.IsValid()
}

func (n TsInterface) TsObjectType() TsObjectType {
	child := n.Child(selector.TsObjectType)
	return TsObjectType{child}
}

type TsInterfaceExtends struct {
	*Node
}

func (n TsInterfaceExtends) TsTypeReference() []TsTypeReference {
	nodes := n.Children(selector.TsTypeReference)
	var ret = make([]TsTypeReference, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsTypeReference{node})
	}
	return ret
}

type TsIntersectionType struct {
	*Node
}

func (n TsIntersectionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TsKeyOfType struct {
	*Node
}

func (n TsKeyOfType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsLiteralType struct {
	*Node
}

func (n TsLiteralType) TsTemplateLiteralType() (TsTemplateLiteralType, bool) {
	child := n.Child(selector.TsTemplateLiteralType)
	return TsTemplateLiteralType{child}, child.IsValid()
}

type TsMappedType struct {
	*Node
}

func (n TsMappedType) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsMappedType) InType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

func (n TsMappedType) AsType() (TsType, bool) {
	child := n.Child(selector.TsType).Next(selector.TsType)
	return ToJsNode(child).(TsType), child.IsValid()
}

func (n TsMappedType) TsTypeAnnotation() TsTypeAnnotation {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}
}

type TsMethodSignature struct {
	*Node
}

func (n TsMethodSignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsMethodSignature) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n TsMethodSignature) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsMethodSignature) Parameters() Parameters {
	child := n.Child(selector.Parameters)
	return Parameters{child}
}

func (n TsMethodSignature) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type TsNamespace struct {
	*Node
}

func (n TsNamespace) NameIdent() []NameIdent {
	nodes := n.Children(selector.NameIdent)
	var ret = make([]NameIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, NameIdent{node})
	}
	return ret
}

func (n TsNamespace) TsNamespaceBody() TsNamespaceBody {
	child := n.Child(selector.TsNamespaceBody)
	return TsNamespaceBody{child}
}

type TsNamespaceBody struct {
	*Node
}

func (n TsNamespaceBody) ModuleItem() []ModuleItem {
	nodes := n.Children(selector.ModuleItem)
	var ret = make([]ModuleItem, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(ModuleItem))
	}
	return ret
}

type TsNamespaceExportDecl struct {
	*Node
}

func (n TsNamespaceExportDecl) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type TsNamespaceName struct {
	*Node
}

func (n TsNamespaceName) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsNonNull struct {
	*Node
}

func (n TsNonNull) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type TsNonNullableType struct {
	*Node
}

func (n TsNonNullableType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsNullableType struct {
	*Node
}

func (n TsNullableType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsObjectType struct {
	*Node
}

func (n TsObjectType) TsTypeMember() []TsTypeMember {
	nodes := n.Children(selector.TsTypeMember)
	var ret = make([]TsTypeMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsTypeMember))
	}
	return ret
}

type TsOptional struct {
	*Node
}

type TsOverride struct {
	*Node
}

type TsParenthesizedType struct {
	*Node
}

func (n TsParenthesizedType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsPredefinedType struct {
	*Node
}

type TsPropertySignature struct {
	*Node
}

func (n TsPropertySignature) Modifier() []Modifier {
	nodes := n.Children(selector.Modifier)
	var ret = make([]Modifier, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(Modifier))
	}
	return ret
}

func (n TsPropertySignature) PropertyName() PropertyName {
	child := n.Child(selector.PropertyName)
	return ToJsNode(child).(PropertyName)
}

func (n TsPropertySignature) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

type TsReadonly struct {
	*Node
}

type TsReadonlyType struct {
	*Node
}

func (n TsReadonlyType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsRestType struct {
	*Node
}

func (n TsRestType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsSatisfiesExpr struct {
	*Node
}

func (n TsSatisfiesExpr) Left() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n TsSatisfiesExpr) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsTemplateLiteralType struct {
	*Node
}

var selectorTsTemplateLiteralTypeTemplate = selector.OneOf(js.NoSubstitutionTemplate, js.TemplateHead, js.TemplateMiddle, js.TemplateTail)

func (n TsTemplateLiteralType) Template() []JsNode {
	nodes := n.Children(selectorTsTemplateLiteralTypeTemplate)
	var ret = make([]JsNode, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(JsNode))
	}
	return ret
}

func (n TsTemplateLiteralType) Substitution() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TsThisParameter struct {
	*Node
}

func (n TsThisParameter) TsTypeAnnotation() TsTypeAnnotation {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}
}

type TsThisType struct {
	*Node
}

type TsTupleType struct {
	*Node
}

func (n TsTupleType) TupleMember() []TupleMember {
	nodes := n.Children(selector.TupleMember)
	var ret = make([]TupleMember, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TupleMember))
	}
	return ret
}

type TsTypeAliasDecl struct {
	*Node
}

func (n TsTypeAliasDecl) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsTypeAliasDecl) TsTypeParameters() (TsTypeParameters, bool) {
	child := n.Child(selector.TsTypeParameters)
	return TsTypeParameters{child}, child.IsValid()
}

func (n TsTypeAliasDecl) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsTypeAnnotation struct {
	*Node
}

func (n TsTypeAnnotation) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsTypeArguments struct {
	*Node
}

func (n TsTypeArguments) TsType() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TsTypeConstraint struct {
	*Node
}

func (n TsTypeConstraint) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsTypeName struct {
	*Node
}

func (n TsTypeName) TsNamespaceName() (TsNamespaceName, bool) {
	child := n.Child(selector.TsNamespaceName)
	return TsNamespaceName{child}, child.IsValid()
}

func (n TsTypeName) Ref() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsTypeOf struct {
	*Node
}

type TsTypeOnly struct {
	*Node
}

type TsTypeParameter struct {
	*Node
}

func (n TsTypeParameter) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

func (n TsTypeParameter) TsTypeConstraint() (TsTypeConstraint, bool) {
	child := n.Child(selector.TsTypeConstraint)
	return TsTypeConstraint{child}, child.IsValid()
}

func (n TsTypeParameter) TsType() (TsType, bool) {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType), child.IsValid()
}

type TsTypeParameters struct {
	*Node
}

func (n TsTypeParameters) TsTypeParameter() []TsTypeParameter {
	nodes := n.Children(selector.TsTypeParameter)
	var ret = make([]TsTypeParameter, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, TsTypeParameter{node})
	}
	return ret
}

type TsTypePredicate struct {
	*Node
}

func (n TsTypePredicate) Paramref() ReferenceIdent {
	child := n.Child(selector.ReferenceIdent)
	return ReferenceIdent{child}
}

func (n TsTypePredicate) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type TsTypeQuery struct {
	*Node
}

func (n TsTypeQuery) ReferenceIdent() []ReferenceIdent {
	nodes := n.Children(selector.ReferenceIdent)
	var ret = make([]ReferenceIdent, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ReferenceIdent{node})
	}
	return ret
}

type TsTypeReference struct {
	*Node
}

func (n TsTypeReference) TsTypeName() TsTypeName {
	child := n.Child(selector.TsTypeName)
	return TsTypeName{child}
}

func (n TsTypeReference) TsTypeArguments() (TsTypeArguments, bool) {
	child := n.Child(selector.TsTypeArguments)
	return TsTypeArguments{child}, child.IsValid()
}

type TsTypeVar struct {
	*Node
}

func (n TsTypeVar) NameIdent() NameIdent {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}
}

type TsUnionType struct {
	*Node
}

func (n TsUnionType) Inner() []TsType {
	nodes := n.Children(selector.TsType)
	var ret = make([]TsType, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, ToJsNode(node).(TsType))
	}
	return ret
}

type TsUniqueType struct {
	*Node
}

func (n TsUniqueType) TsType() TsType {
	child := n.Child(selector.TsType)
	return ToJsNode(child).(TsType)
}

type UnaryExpr struct {
	*Node
}

func (n UnaryExpr) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

type Var struct {
	*Node
}

type VarDecl struct {
	*Node
}

func (n VarDecl) BindingPattern() (BindingPattern, bool) {
	child := n.Child(selector.BindingPattern)
	return ToJsNode(child).(BindingPattern), child.IsValid()
}

func (n VarDecl) NameIdent() (NameIdent, bool) {
	child := n.Child(selector.NameIdent)
	return NameIdent{child}, child.IsValid()
}

func (n VarDecl) TsExclToken() (TsExclToken, bool) {
	child := n.Child(selector.TsExclToken)
	return TsExclToken{child}, child.IsValid()
}

func (n VarDecl) TsTypeAnnotation() (TsTypeAnnotation, bool) {
	child := n.Child(selector.TsTypeAnnotation)
	return TsTypeAnnotation{child}, child.IsValid()
}

func (n VarDecl) Initializer() (Initializer, bool) {
	child := n.Child(selector.Initializer)
	return Initializer{child}, child.IsValid()
}

type VarStmt struct {
	*Node
}

func (n VarStmt) VarDecl() []VarDecl {
	nodes := n.Children(selector.VarDecl)
	var ret = make([]VarDecl, 0, len(nodes))
	for _, node := range nodes {
		ret = append(ret, VarDecl{node})
	}
	return ret
}

type WhileStmt struct {
	*Node
}

func (n WhileStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n WhileStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type WithStmt struct {
	*Node
}

func (n WithStmt) Expr() Expr {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr)
}

func (n WithStmt) Stmt() Stmt {
	child := n.Child(selector.Stmt)
	return ToJsNode(child).(Stmt)
}

type Yield struct {
	*Node
}

func (n Yield) Expr() (Expr, bool) {
	child := n.Child(selector.Expr)
	return ToJsNode(child).(Expr), child.IsValid()
}

type MultiLineComment struct {
	*Node
}

type SingleLineComment struct {
	*Node
}

type InvalidToken struct {
	*Node
}

type NoSubstitutionTemplate struct {
	*Node
}

type TemplateHead struct {
	*Node
}

type TemplateMiddle struct {
	*Node
}

type TemplateTail struct {
	*Node
}

type InsertedSemicolon struct {
	*Node
}
