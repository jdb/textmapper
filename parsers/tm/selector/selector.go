// generated by Textmapper; DO NOT EDIT

package selector

import (
	"github.com/inspirer/textmapper/parsers/tm"
)

type Selector func(nt tm.NodeType) bool

var (
	Any                  = func(t tm.NodeType) bool { return true }
	ArgumentFalse        = func(t tm.NodeType) bool { return t == tm.ArgumentFalse }
	ArgumentTrue         = func(t tm.NodeType) bool { return t == tm.ArgumentTrue }
	ArgumentVal          = func(t tm.NodeType) bool { return t == tm.ArgumentVal }
	Array                = func(t tm.NodeType) bool { return t == tm.Array }
	Assoc                = func(t tm.NodeType) bool { return t == tm.Assoc }
	BooleanLiteral       = func(t tm.NodeType) bool { return t == tm.BooleanLiteral }
	Command              = func(t tm.NodeType) bool { return t == tm.Command }
	DirectiveAssert      = func(t tm.NodeType) bool { return t == tm.DirectiveAssert }
	DirectiveBrackets    = func(t tm.NodeType) bool { return t == tm.DirectiveBrackets }
	DirectiveExpect      = func(t tm.NodeType) bool { return t == tm.DirectiveExpect }
	DirectiveExpectRR    = func(t tm.NodeType) bool { return t == tm.DirectiveExpectRR }
	DirectiveInject      = func(t tm.NodeType) bool { return t == tm.DirectiveInject }
	DirectiveInput       = func(t tm.NodeType) bool { return t == tm.DirectiveInput }
	DirectiveInterface   = func(t tm.NodeType) bool { return t == tm.DirectiveInterface }
	DirectivePrio        = func(t tm.NodeType) bool { return t == tm.DirectivePrio }
	DirectiveSet         = func(t tm.NodeType) bool { return t == tm.DirectiveSet }
	Empty                = func(t tm.NodeType) bool { return t == tm.Empty }
	ExclusiveStartConds  = func(t tm.NodeType) bool { return t == tm.ExclusiveStartConds }
	Extend               = func(t tm.NodeType) bool { return t == tm.Extend }
	File                 = func(t tm.NodeType) bool { return t == tm.File }
	Header               = func(t tm.NodeType) bool { return t == tm.Header }
	Identifier           = func(t tm.NodeType) bool { return t == tm.Identifier }
	Import               = func(t tm.NodeType) bool { return t == tm.Import }
	InclusiveStartConds  = func(t tm.NodeType) bool { return t == tm.InclusiveStartConds }
	Inline               = func(t tm.NodeType) bool { return t == tm.Inline }
	InlineParameter      = func(t tm.NodeType) bool { return t == tm.InlineParameter }
	Inputref             = func(t tm.NodeType) bool { return t == tm.Inputref }
	IntegerLiteral       = func(t tm.NodeType) bool { return t == tm.IntegerLiteral }
	Lexeme               = func(t tm.NodeType) bool { return t == tm.Lexeme }
	LexemeAttribute      = func(t tm.NodeType) bool { return t == tm.LexemeAttribute }
	LexemeAttrs          = func(t tm.NodeType) bool { return t == tm.LexemeAttrs }
	LexemeId             = func(t tm.NodeType) bool { return t == tm.LexemeId }
	LexerSection         = func(t tm.NodeType) bool { return t == tm.LexerSection }
	LexerState           = func(t tm.NodeType) bool { return t == tm.LexerState }
	ListSeparator        = func(t tm.NodeType) bool { return t == tm.ListSeparator }
	LookaheadPredicate   = func(t tm.NodeType) bool { return t == tm.LookaheadPredicate }
	NamedPattern         = func(t tm.NodeType) bool { return t == tm.NamedPattern }
	NoEoi                = func(t tm.NodeType) bool { return t == tm.NoEoi }
	NonEmpty             = func(t tm.NodeType) bool { return t == tm.NonEmpty }
	Nonterm              = func(t tm.NodeType) bool { return t == tm.Nonterm }
	NontermAlias         = func(t tm.NodeType) bool { return t == tm.NontermAlias }
	NontermParams        = func(t tm.NodeType) bool { return t == tm.NontermParams }
	Not                  = func(t tm.NodeType) bool { return t == tm.Not }
	Option               = func(t tm.NodeType) bool { return t == tm.Option }
	ParamModifier        = func(t tm.NodeType) bool { return t == tm.ParamModifier }
	ParamRef             = func(t tm.NodeType) bool { return t == tm.ParamRef }
	ParamType            = func(t tm.NodeType) bool { return t == tm.ParamType }
	ParserSection        = func(t tm.NodeType) bool { return t == tm.ParserSection }
	Pattern              = func(t tm.NodeType) bool { return t == tm.Pattern }
	Predicate            = func(t tm.NodeType) bool { return t == tm.Predicate }
	PredicateAnd         = func(t tm.NodeType) bool { return t == tm.PredicateAnd }
	PredicateEq          = func(t tm.NodeType) bool { return t == tm.PredicateEq }
	PredicateNot         = func(t tm.NodeType) bool { return t == tm.PredicateNot }
	PredicateNotEq       = func(t tm.NodeType) bool { return t == tm.PredicateNotEq }
	PredicateOr          = func(t tm.NodeType) bool { return t == tm.PredicateOr }
	RawType              = func(t tm.NodeType) bool { return t == tm.RawType }
	ReportAs             = func(t tm.NodeType) bool { return t == tm.ReportAs }
	ReportClause         = func(t tm.NodeType) bool { return t == tm.ReportClause }
	RhsAlias             = func(t tm.NodeType) bool { return t == tm.RhsAlias }
	RhsAssignment        = func(t tm.NodeType) bool { return t == tm.RhsAssignment }
	RhsCast              = func(t tm.NodeType) bool { return t == tm.RhsCast }
	RhsEmpty             = func(t tm.NodeType) bool { return t == tm.RhsEmpty }
	RhsIgnored           = func(t tm.NodeType) bool { return t == tm.RhsIgnored }
	RhsLookahead         = func(t tm.NodeType) bool { return t == tm.RhsLookahead }
	RhsNested            = func(t tm.NodeType) bool { return t == tm.RhsNested }
	RhsOptional          = func(t tm.NodeType) bool { return t == tm.RhsOptional }
	RhsPlusAssignment    = func(t tm.NodeType) bool { return t == tm.RhsPlusAssignment }
	RhsPlusList          = func(t tm.NodeType) bool { return t == tm.RhsPlusList }
	RhsPlusQuantifier    = func(t tm.NodeType) bool { return t == tm.RhsPlusQuantifier }
	RhsPrec              = func(t tm.NodeType) bool { return t == tm.RhsPrec }
	RhsSet               = func(t tm.NodeType) bool { return t == tm.RhsSet }
	RhsStarList          = func(t tm.NodeType) bool { return t == tm.RhsStarList }
	RhsStarQuantifier    = func(t tm.NodeType) bool { return t == tm.RhsStarQuantifier }
	RhsSymbol            = func(t tm.NodeType) bool { return t == tm.RhsSymbol }
	Rule                 = func(t tm.NodeType) bool { return t == tm.Rule }
	SetAnd               = func(t tm.NodeType) bool { return t == tm.SetAnd }
	SetComplement        = func(t tm.NodeType) bool { return t == tm.SetComplement }
	SetCompound          = func(t tm.NodeType) bool { return t == tm.SetCompound }
	SetOr                = func(t tm.NodeType) bool { return t == tm.SetOr }
	SetSymbol            = func(t tm.NodeType) bool { return t == tm.SetSymbol }
	StartConditions      = func(t tm.NodeType) bool { return t == tm.StartConditions }
	StartConditionsScope = func(t tm.NodeType) bool { return t == tm.StartConditionsScope }
	StateMarker          = func(t tm.NodeType) bool { return t == tm.StateMarker }
	Stateref             = func(t tm.NodeType) bool { return t == tm.Stateref }
	StringLiteral        = func(t tm.NodeType) bool { return t == tm.StringLiteral }
	Symref               = func(t tm.NodeType) bool { return t == tm.Symref }
	SymrefArgs           = func(t tm.NodeType) bool { return t == tm.SymrefArgs }
	SyntaxProblem        = func(t tm.NodeType) bool { return t == tm.SyntaxProblem }
	TemplateParam        = func(t tm.NodeType) bool { return t == tm.TemplateParam }
	InvalidToken         = func(t tm.NodeType) bool { return t == tm.InvalidToken }
	MultilineComment     = func(t tm.NodeType) bool { return t == tm.MultilineComment }
	Comment              = func(t tm.NodeType) bool { return t == tm.Comment }
	Templates            = func(t tm.NodeType) bool { return t == tm.Templates }
	Argument             = OneOf(tm.Argument...)
	Expression           = OneOf(tm.Expression...)
	GrammarPart          = OneOf(tm.GrammarPart...)
	LexerPart            = OneOf(tm.LexerPart...)
	Literal              = OneOf(tm.Literal...)
	NontermParam         = OneOf(tm.NontermParam...)
	ParamValue           = OneOf(tm.ParamValue...)
	PredicateExpression  = OneOf(tm.PredicateExpression...)
	RhsPart              = OneOf(tm.RhsPart...)
	Rule0                = OneOf(tm.Rule0...)
	SetExpression        = OneOf(tm.SetExpression...)
)

func OneOf(types ...tm.NodeType) Selector {
	if len(types) == 0 {
		return func(tm.NodeType) bool { return false }
	}
	const bits = 32
	max := 1
	for _, t := range types {
		if int(t) > max {
			max = int(t)
		}
	}
	size := (max + bits) / bits
	bitarr := make([]uint32, size)
	for _, t := range types {
		bitarr[uint(t)/bits] |= 1 << (uint(t) % bits)
	}
	return func(t tm.NodeType) bool {
		i := uint(t) / bits
		return int(i) < len(bitarr) && bitarr[i]&(1<<(uint(t)%bits)) != 0
	}
}
